##### 5. Virtual functions, function overloading vs function overriding, usage of virtual functions, examples, pure virtual functions, virtual destructors, exception handling.

## 1. Виртуальные функции (Virtual Functions)

**Виртуальная функция** в C++ — это функция, объявленная в базовом классе с ключевым словом `virtual`, которая может быть *переопределена* (overridden) в производном классе. Главная особенность: при вызове такой функции через *указатель или ссылку* на базовый класс, но фактически указывающий на объект производного класса, будет вызвана *реальная* (переопределённая) функция из производного класса.

Это механизм *динамического полиморфизма* (runtime polymorphism): решение о том, какая реализация функции вызывается, происходит во *время выполнения*, а не на этапе компиляции.

[1.1.1 Пример]
```cpp
class Base {
public:
// Виртуальная функция
    virtual void display() {
        std::cout << "Base class" << std::endl;
    }

// Виртуальный деструктор (рассмотрим позже в разделе "Виртуальные деструкторы")
    virtual ~Base() = default;
};

class Derived : public Base {
public:
// Переопределение виртуальной функции
    void display() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->display(); // Выведет: "Derived class" (динамический полиморфизм)
    delete basePtr;
    return 0;
}
```

Если бы `display()` *не была объявлена `virtual` в классе `Base`, то вызов `basePtr->display()` *всегда* вызывал бы метод `Base::display()`, несмотря на то, что `basePtr` указывает на объект `Derived`.

### 1.1.2 Ключевое слово `override`

Начиная с C++11, при переопределении виртуальной функции в производном классе рекомендуется использовать ключевое слово `override`. Оно указывает компилятору, что метод действительно должен переопределять виртуальную функцию из базового класса. Если в базовом классе не было подходящей виртуальной функции с такой же сигнатурой, произойдёт ошибка компиляции (что помогает избежать опечаток и скрытых ошибок).
```cpp
class Derived : public Base {
public:
    void display() override { // override даёт дополнительную проверку от компилятора
        std::cout << "Derived class" << std::endl;
    }
};
```

### 1.1.3 Ключевое слово `final`

Если нужно запретить дальнейшее переопределение виртуальной функции в классах-наследниках, можно использовать ключевое слово `final`:
```cpp
class Derived : public Base {
public:
    void display() override final {
        std::cout << "Derived class" << std::endl;
    }
};

class MoreDerived : public Derived {
public:
    // Ошибка! display() объявлен как final в классе Derived
    void display() override {
        std::cout << "MoreDerived class" << std::endl;
    }
};

```

Также ключевое слово `final` можно применять к самому классу, чтобы запретить от него наследоваться.


## 2. Перегрузка функций (Function Overloading) vs Переопределение функций (Function Overriding)

### 2.1 Перегрузка функций (Function Overloading)
- **Определение**: Перегрузка — это механизм, при котором в *одном и том же классе* (или в одной области видимости) можно объявить несколько функций с одним именем, *но разным списком параметров* (типы, количество, порядок).
- **Когда происходит выбор**: Во *время компиляции* (compile-time).
- **Цель**: Удобство использования одного и того же «имени операции», но с разными типами данных.

[Пример]
```cpp
void print(int i) {
    std::cout << "Integer: " << i << std::endl;
}

void print(double d) {
    std::cout << "Double: " << d << std::endl;
}

void print(std::string s) {
    std::cout << "String: " << s << std::endl;
}

```
Здесь три функции `print`, которые отличаются набором параметров. Компилятор по типу аргументов в момент вызова решает, какую функцию вызвать.

#### Особенности перегрузки
- Параметры должны различаться по **типам**, **количеству** или **порядку**.
- Возвращаемый тип **не** участвует в выборе перегруженной функции.
- Это **статический полиморфизм** (compile-time polymorphism).

## 2.2 Переопределение функций (Function Overriding)

- **Определение**: Переопределение (overriding) — это механизм, при котором *производный класс* предоставляет *новую реализацию* виртуальной функции, объявленной в *базовом классе*.
- **Когда происходит выбор**: Во *время выполнения* (runtime), если вызов идёт через указатель/ссылку на базовый класс. (`Base* basePtr = new Derived(); basePtr->display()`)
- **Цель**: Реализовать полиморфизм; предоставить уникальное поведение для разных типов, имеющих общий интерфейс.

[Пример]
```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base show\n";
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived show\n";
    }
};

```

#### Отличие от перегрузки

- **Перегрузка** (overloading) — несколько функций **в одном классе** с одним именем, но **разными параметрами** (compile-time).
- **Переопределение** (overriding) — одна и та же функция (по сигнатуре) в базовом и производном классе, с ключевым словом `virtual` в базовом классе (runtime).


## 3. Использование виртуальных функций

Виртуальные функции применяются:

1. *Для организации общего интерфейса* в базовом классе, с разными реализациями в производных классах.
2. *Для хранения и обработки объектов разнородных типов* (но с общей базой) в *контейнерах*, используя динамический полиморфизм.

[Небольшой пример с «животными», где у каждого животного свой звук]
```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Some generic animal sound\n";
    }

    virtual ~Animal() = default; // виртуальный деструктор
};

class Dog : public Animal {
public:
    void sound() override {
        std::cout << "Woof!\n";
    }
};

class Cat : public Animal {
public:
    void sound() override {
        std::cout << "Meow!\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->sound(); // Woof!
    a2->sound(); // Meow!

    delete a1;
    delete a2;
    return 0;
}

```
Если бы не было виртуальной функции, всегда вызывался бы метод `Animal::sound()`.


## 4. Чисто виртуальные функции (Pure Virtual Functions)

Чисто виртуальная функция — это виртуальная функция, **не имеющая реализации** в базовом классе. Синтаксис:
`virtual void functionName() = 0;`

Класс, содержащий хотя бы одну чисто виртуальную функцию, называется **абстрактным классом** (abstract class). Экземпляры абстрактных классов **нельзя** создавать напрямую. Такой класс обычно служит «интерфейсом» или базой для наследования.

[Пример]
```cpp
class Shape {
public:
    virtual void draw() = 0; // чисто виртуальная функция
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing Circle\n";
    }
};

class Square : public Shape {
public:
    void draw() override {
        std::cout << "Drawing Square\n";
    }
};

int main() {
    // Shape s; // Ошибка: класс Shape — абстрактный, нельзя создавать объекты
    Shape* c = new Circle();
    Shape* sq = new Square();

    c->draw();   // Drawing Circle
    sq->draw();  // Drawing Square

    delete c;
    delete sq;
    return 0;
}

```
Чисто виртуальный метод `draw()` заставляет **каждый** производный класс **обязательно** предоставлять свою реализацию.

### Чисто виртуальный деструктор

Иногда делают и деструктор чисто виртуальным:
```cpp
class AbstractBase {
public:
    virtual ~AbstractBase() = 0; // объявляем как чисто виртуальный
};

inline AbstractBase::~AbstractBase() {
    // даже для чисто виртуального деструктора нужно тело
}

```
Зачем? Чтобы класс нельзя было инстанциировать, но при этом чтобы деструктор оставался виртуальным (для корректного удаления производных).


## 5. Виртуальные деструкторы (Virtual Destructors)

### Зачем нужны?

Если класс содержит хотя бы одну виртуальную функцию (или предполагается использовать полиморфизм), **настойчиво рекомендуется** объявлять деструктор виртуальным. Иначе при удалении объекта производного класса через указатель базового типа может не вызваться деструктор производного класса, что часто приводит к утечкам ресурсов.

[Пример]
```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // сначала ~Derived(), потом ~Base()
    return 0;
}

```

Вывод:
`Derived destructor Base destructor`

Если убрать `virtual` у деструктора `Base`, то при `delete obj` вызвался бы *только* `~Base()`, а `~Derived()` — *нет*, что привело бы к утечкам или некорректному освобождению.



## 6. Обработка исключений (Exception Handling)

Исключения — это механизм языка, позволяющий «выбрасывать» (throw) и «ловить» (catch) ошибки, которые могут возникнуть в программе. В С++ он позволяет отделить *логику обработки ошибок* от *основного потока кода*.

**Синтаксис:**
```cpp
try {
    // Блок кода, где может произойти ошибка
    // ...
    throw std::runtime_error("Some error"); 
} 
catch (const std::exception& e) {
    // Блок, который перехватывает исключения типа std::exception и его наследников
    std::cerr << "Exception: " << e.what() << std::endl;
}
catch (...) {
    // "Поймать всё" — ловит исключения любого типа
    std::cerr << "Unknown exception caught!\n";
}

```

[Пример]
```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 2) << std::endl;  // 5
        std::cout << divide(10, 0) << std::endl;  // исключение!
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}

```

- При вызове `divide(10, 0)` генерируется исключение `std::runtime_error`, которое перехватывается блоком `catch (const std::exception& e)`.
- `what()` — это метод, определённый в классе `std::exception` (и его производных) в C++. Он используется для получения текста сообщения об исключении в виде строки.

### Дополнительные моменты

- **Стек раскручивается** (stack unwinding) — объекты локальных переменных уничтожаются по пути выхода из функции, где возникло исключение.
- Можно объявлять и *свои* классы исключений, например, наследуясь от `std::exception`.
- Ключевое слово `noexcept` в современном C++ указывает, что функция *не* будет выбрасывать исключения. При нарушении этого обещания программа обычно завершается (`std::terminate).
- В *конструкторах* исключения разрешены, но нужно аккуратно продумать последствия. В *деструкторах* бросать исключения крайне не рекомендуется (если при разрушении объекта выбросится исключение, а одновременно выбросится ещё одно исключение из другого деструктора, это приведёт к `std::terminate()`).


## 7. Дополнительно о полиморфизме и исключениях

- **RTTI (RunTime Type Information)**: при использовании виртуальных функций C++ даёт возможность динамически определять тип объекта (операторы `typeid`, `dynamic_cast`).
- **Abstract Class vs Interface** (понятие из Java): в C++ нет специального термина «интерфейс», но его можно моделировать абстрактным классом, у которого все методы — чисто виртуальные.



### Итоги

1. **Виртуальные функции** — это ключевой механизм *динамического полиморфизма*. Они позволяют определять, какая версия функции (базовая или производная) должна быть вызвана *во время выполнения*.
2. **Перегрузка (overloading)** и **переопределение (overriding)** — это разные понятия:
    - **Перегрузка**: несколько функций *в одном классе* с одним именем и *разными параметрами* (compile-time).
    - **Переопределение**: новая реализация виртуальной функции *в производном классе* (runtime).
3. **Чисто виртуальные функции** превращают класс в *абстрактный*, заставляя производные классы предоставлять собственную реализацию.
4. **Виртуальный деструктор** необходим для корректного удаления объектов производных классов через указатель на базовый класс (избежание утечек и некорректного освобождения).
5. **Обработка исключений** даёт возможность отделять логику работы с ошибками от основной логики программы и обеспечивает корректное освобождение ресурсов при возникновении ошибок.


