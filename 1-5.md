
 
---

##### 4. l-value/r-value references, std::move, move constructor, move assignment operator, Type casting in c++: static_cast, reinterpret_cast, const_cast.
### **l-value и r-value**

```cpp
#include <iostream>
#include <cmath>
#include <string>

// В данной функции объясняется, что такое l-value и r-value выражения, а также характеристики выражений в C++.
void l_value_vs_r_value_and_expression_characteristics()
{
   l-value (или left-value) есть выражение, которое может хотя бы раз оказаться слева от знака =.
   r-value (или right-value) есть выражение, которое может оказаться лишь справа от знака = и не может оказаться слева.
   Например:

   int x = 10;          x - lvalue, так как можно написать x=12;
   const double y = 19; y - lvalue, так как на этой же строке y оказалась слева от знака =.
   8;                   8 - r-value, так как нельзя написать, например, 8=1+3;
   x + 1;               x+1 - r-value, так как нельзя написать, например, x+1=666;
   "Hello World";       "Hello World" - r-value, так как нельзя написать, например "Hello World" = "Goodbye World";

   У всякого выражения в C++ есть 3 характеристики:
   1. Type        (тип)
   2. Value       (значение)
   3. Side-Effect (побочный эффект)

   Примеры характеристик выражений:

   Пример 1.
   {
      double a = 19;
      a + 1; 1. double
             2. 20
             3. Ничего
   }
   Пример 2.
   {
      int a = 7;
      a = 7; 1. int
             2. 7 (так как если напечатать std::cout << (a=7); выведется 7)
             3. Изменить значение a на 7
   }
   Пример 3.
   {
      "Hello World"; 1. char*
                     2. "Hello World"
                     3. Ничего
   }
   Пример 4.
   {
      int a = 15;
      ++a;   1. int
             2. 16 (так как если напечатать std::cout << (++a); выведется 16)
             3. Увеличить значение a на 1
   }
   Пример 5.
   {
      int a = 15;
      a++;   1. int
             2. 15 (так как если напечатать std::cout << (a++); выведется 15)
             3. Увеличить значение a на 1
   }

   Подытожим:
   {
      int a = 15;
      std::cout << ++a << "\n"; Напечатает 16, т.е. новое значение а. <---------------------------------------------
      std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта ++a.    |
   }                            |                                                                                   | Сравните
   {                            |                                                                                   |
      int a = 15;               |                                                                                   |
      std::cout << a++ << "\n"; Напечатает 15, т.е. исходное значение а. <------------------------------------------
      std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта a++.
   }

   Таким образом префиксный инкремент и постфикстный инкремент увеличивают переменную на 1,
   но значение префиксного инкремента - новое значение переменной после увеличения,
   а значение постфиксного инкремента - исходное значение переменной до увеличения.
   
   Кроме того:
   ++x; l-value, так как можно написать, например, ++x=12; <---Значение х поменяется на 12.
   x++; r-value, так как нельзя написать, например, x++=12; <---Ошибка компиляции.

   ЗАМЕЧАНИЕ: Всё у чего есть имя l-value, но всё у чего нет имени ещё не значит, что r-value.
             Достаточным условием того, что какое-то выражение было l-value, является существование имени для этого выражения.
   Например: 
             1. x;   x-название переменной => оно точно l-value.
             2. ++x; ++x не название переменной, но это всё ещё l-value.
             3. x++; x++ не название переменной, но в этот раз это r-value.

   Другие примеры l-value выражений:
   x = y;
   x += 1;
   x = x * 20;
   --x;

   Другие примеры r-value выражений:
   x + 1;
   std::abs(x);
   std::sqrt(y);
   10;
   's';
   3.14;
   "This is too an r-value expression";
   x--;
}

void references_and_const_references()
{
   int x = 19;
   int copy = x;

   int& ref = x;

   copy = 777;
   std::cout << x << "\n";
   ref = 777;
   std::cout << x << "\n";

   const int constantInteger = 7;
   const int& constantReference = constantInteger;

   const int& constantReference2 = x;
   const int& constantReference3 = x + 123;
}

void print(std::string str)
{
   std::cout << str;
}

void print1(std::string& str)
{
   std::cout << str;
}

void print2(const std::string& str)
{
   std::cout << str;
}

int main()
{
}


```

```cpp
#include <iostream>

В данной функции объясняется что такое r-value референс.
void r_value_reference()
{
   Будет использовано позже.
   int x = 10;

   Те референсы, которые были обсуждены в файле References.cpp называются l-value референсами
   и они присутствовали в C++ с самого начала его существования.
   
   Называются они l-value референсами так как неконстантные референсы могут ссылаться лишь на
   l-value выражения. Но как мы уже поняли есть потребность создавать функции,
   которые получали бы l-value значения по-ссылке (чтобь избежат копирования),
   но могли бы также получать r-value значения (см. функцию print2 в References.cpp).
   Именно по-этому было решено разрешать присваивать константным ссылкам как l-value, так и r-value значения.
   
   Но что если по каким-то причинам мы хотим создать отдельно 2 функции с одним и тем же именем,
   так, чтобы первая из них вызывалась бы если было передано l-value значение, а вторая вызывалась
   бы, если было передано r-value значение?
   
   Как раз для этого случая существуют r-value референсы, которые были добавлены в C++11,
   их синтаксис следующий:
   
   <тип>&& <название референса> = <r-value значение>;
   
   Например:
   int&& r_value_ref = x + 1;

   Замечания:
   1. r-value референс может ссылаться лишь на r-value значение (удлинняя жизнь временной переменной).
      т.е. запись int&& ref=x; привела бы к ошибке компиляции, так как х - l-value.
   2. r-value референсы как и l-value референсы должны быть инициализированны, т.е. нельзя писать
      int&& ref; <---- Ошибка компиляции.

   --------->[ВОПРОС] Как уже было сказано r-value референс может ссылаться лишь на r-value значение,
                      но сам этот референс представляет из себя нечто l-value или r-value?
                      То есть может ли он оказаться слева от знака =?
   Ответ: Так как у r_value_ref есть имя, то оно является l-value, как уже было сказано в References.cpp
   Подытожив: r_value_ref может ссылаться лишь на r-value значение, но сам r_value_ref - l-value.
   Пример: Можно менять значение r-value референса
   r_value_ref = 19;
   ++r_value_ref;
   r_value_ref /= 10;

   Замечание: Значение константных r-value референсов поменять нельзя и ссылаться они могут
              лишь на r-value выражения. Пример:
   const int&& const_r_value_ref = 10 / x + 3 - r_value_ref;

   --------->[ВОПРОС] На что могут ссылаться константные/неконстантные l-value/r-value референсы?
   Ответ: Смотри таблицу
   
                      |           non-const               |                const                |
   -------------------|-----------------------------------|-------------------------------------|
    l-value reference | only non-const l-value expression | any l-value and r-value expression  |
   -------------------|-----------------------------------|-------------------------------------|
    r-value reference |     only r-value expression       |      only r-value expression        | 
   -------------------|-----------------------------------|-------------------------------------|
   
}

Далее приводятся примеры функций, принимающих l-value и r-value референсы.

void f(int& x) // принимает неконстантный l-value референс.
{
   std::cout << "x was l-value\n";
}

void f(int&& x) // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   f(var);
   f(var + 1);
   f(777);
}

То на 78-ой строке вызовется первая функция,
а на 80-ой и 81-ой строке вызовется вторая и будет напечатано

x was l-value
x was r-value
x was r-value

Всё из-за того, что
1. На 79-ой строке аргумент переданный функции является l-value и будет вызвана первая функция
2. На 80-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция
3. На 81-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция

Другой пример с константным l-value референсом:
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   g(var);
   g(var + 1);
   g(777);
}

-------->[ВОПРОС]: И первая и вторая функция могут принимать r-value значения,
                   Так какая из них вызовется на 114-ой и 115-ой строках?
Ответ: Как ни странно - приоритет получения r-value значений дается именно r-value референсам.
        Таким образом мы увидим тот же результат, что и для f:

        x was l-value
        x was r-value
        x was r-value

-------->[ВОПРОС]: Чем отличаются функции g и f?
Ответ: Нельзя передать f константную переменную, например
      
        const int val = 777;
        f(val);

        Не скомпилируется, так как
        1. f на 64-ой принимает неконстантную ссылку, следовательно нельзя передать константное.
        2. f на 69-ой строке принимает r-value референс, следовательно нельзя передать l-value.
        а val константное l-value значение.

        С другой стороны f можно поменять на g в 131-ой строке и компиляция пройдет.

-------->[ВОПРОС]: Что изменилось бы если в 69-ой и 103-ей строках r-value референсы были константными, т.е.
                   void f(const int&& x)
                   void g(const int&& x)
Ответ: Всё что было сказано до этого не изменилось бы. Единственное отличие было бы в том,
        что внутри самих функций x нельзя было бы поменять.

-------->[САМЫЙ ВАЖНЫЙ ВОПРОС]: Для чего это всё нужно?
Ответ: Нужно всё для того, чтобы изменить поведение функции в зависимости от того было ли
        переданно данной функции l-value или r-value, а надобность этого будет понятна
        после прочтения MoveSemantics.cpp.

```

---

### **std::move**

```cpp
#include <iostream>
#include <utility>
#include <string>

В данном файле мы поверхностно поймем, что такое move-семантика.

Рассмотрим следующий сценарий: Есть функция, которая принимает std::string по значению
void f(std::string str)
{
   какие-то действия с str.
}

Заметим, что при следующей передаче переменной функции

int main()
{
   std::string name="Barak Obama";
   f(name);
}
  
Переменная name будет скопирована в str.

Подытожим: В 17ой строке будет создана переменная name
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

А в 18ой строке name будет скопирован в str функции f и будем иметь
 _______________         _______________
|     name      |       |      str      |
|---------------|       |---------------|
| "Barak Obama" |       | "Barak Obama" |
 ---------------         ---------------

-------->[ВОПРОС] А что делать если переменная name нам в main уже ненужна?
                  Ведь тогда логично было бы не создавать копию name, а просто "передать"?
Ответ: Если функцию f изменить нельзя - как раз для этого используется std::move.
       Если написать
 
       int main()
       {
          std::string name="Barak Obama";
          f(std::move(name));
       }

       тогда name не будет скопирован в str, а будет "сдвинут" str.

Подытожим: В 45ой строке будет создана переменная name
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

А в 46ой строке значение name будет мувнуто в str
 _________________         _______________
|       name      |       |      str      |
|-----------------|       |---------------|
| пустое значение |       | "Barak Obama" |
 -----------------         ---------------

Таким образом значение name не будет скопировано, но будет использоваться в str.
Для ясности: "Barak Obama" сохраняется при помощи указателя и вместо того,
             чтобы скопировать саму строку - копируется лишь указатель, а старый указатель
             стирается, то есть:
1. Сперва создается переменная name

 ______
| name |
|------|
|   -----------------> "Barak Obama"   
 ------

 2. При создании переменной str копируется лишь адрес строки, а указатель в name стирается

                     _____
                    | str |
                    |-----|
                    |  |  |
                     --|--
                       |
                       |
 ______                 |
| name |                |
|------|                v
|      |               "Barak Obama"
 ------

---------->[ЗАМЕЧАНИЕ] После std::move переменной name пользоваться нельзя, непонятно какое значение
                       внутри name, что приводит к undefined behavior.

Поймём как работает std::move.

Снова вернемся к примеру из R-valueReferences.cpp
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

------>[ВОПРОС] Что если у нас есть переменная int val=555; и мы хотим передать его
                функции g, но хотим, чтобы вызвалась не функция на строке 99, а на 104?
                Причем мы не хотим менять сами функции.
Очень Странный Ответ: Использовать std::move, а именно

       int val = 555;
       g(std::move(val)); // напечатает "x was r-value"

------>[ВОПРОС] Что же делает std::move? Почему это работает так?
Ответ: Единственная функция std::move - полученное l-value значение преобразовать в r-value.
       Как раз поэтому на строке 114 вызовется функция с строки 104, хоть val и l-value.

------>[ВОПРОС] А как же тогда всё работает для std::move(name) из строки 46?
Ответ: std::string имеет 2 конструктора. Первый из них - это copy-constructor, который принимает l-value reference.
       
       string(const string& other);

       Данный конструктор копирует всю строку other в создаваемый объект.
       Второй же конструктор принимает r-value reference.

       string(string&& other);

       И копирует лишь указатель строки other в создаваемый объект, далее стирает указатель other (именно поэтому тут не const).
       
       Таким образом, вернувшись к функции f, если переменная была передана ей не используя std::move, т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(name);
       }
       То для name будет вызван copy-constructor, так как name l-value и вызовется конструктор на строке 123.

       Если же перед передачей сделать std::move(name), т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(std::move(name));
       }
       Тогда из-за того, что std::move(name) r-value вызовится конструктор, принимающий r-value reference на строке 128.
       Конструктор на строке 128 называется мув конструктором.

```
- **Определение**: `std::move` — это функция, которая преобразует l-value в r-value, позволяя передать временный объект в функции или конструкторы перемещения.
- **Пример**:
  ```cpp
  std::string str = "Hello";
  std::string movedStr = std::move(str); // str теперь пустой
  ```
- **Особенности**:
  - После вызова `std::move` исходный объект теряет свои данные (но остаётся валидным).
  - Используется для оптимизации копирования больших объектов.

---

## **Конструктор перемещения (move constructor)**

- ***Определение***: Конструктор перемещения позволяет передавать ресурсы (например, динамическую память) от одного объекта к другому без копирования.
- *Синтаксис:
  ```cpp
  class MyClass {
  private:
	  int* data;

  public:
	  MyClass(int value) {
		  data = new int(value);
	  }

	  // Конструктор перемещения
	  MyClass(MyClass&& other) noexcept : data(other.data) {
		  other.data = nullptr; // Обнуляем указатель в исходном объекте
	  }

	  ~MyClass() {
		  delete data;
	  }
  };
  ```
- **Особенности**:
  - Конструктор перемещения вызывается, если объект передаётся как r-value.

---

### Оператор присваивания с перемещением (move assignment operator)

- ***Определение***: Оператор перемещающего присваивания используется для переноса ресурсов между объектами.
- *Синтаксис*:
  ```cpp
  MyClass& operator=(MyClass&& other) noexcept {
	  if (this != &other) {
		  delete data;
		  data = other.data;
		  other.data = nullptr;
	  }
	  return *this;
  }
  ```
- **Особенности**:
  - Необходимо очищать текущие ресурсы перед переносом.
  - Обеспечивает защиту от самоприсваивания.

---

# Приведение типов в C++ (type casting in c++)

### static_cast
- **Определение**: Используется для проверяемого преобразования типов во время компиляции. Преобразует, если существует логическая связь и преобразование не приводит к потери данных.

- **Пример**:
  ```cpp
  double d = 3.14;
  int i = static_cast<int>(d); // Убрана дробная часть
  ```
- **Особенности**:
  - Используется для приведения указателей между базовым и производным классами.

### reinterpret_cast
- **Определение**: 
  Это низкоуровневое преобразование, которое **не меняет содержимое памяти**. Оно просто интерпретирует её как другой тип. Используется для небезопасного преобразования типов. Если мы уверены, что преобразование не приведёт к undefined behavior, то можем сделать этот каст. В отличие от других видов приведения (`static_cast`, `const_cast`), `reinterpret_cast` чаще всего используется для низкоуровневых преобразований, связанных с указателями, функциями и значениями.
  
-  **Синтаксис**
```cpp
reinterpret_cast<тип-назначения>(выражение);
```
- **`тип-назначения`** — это тип, в который нужно преобразовать объект.
- **`выражение`** — это значение, которое нужно преобразовать.

- **Пример**:
  ```cpp
  int* p = reinterpret_cast<int*>(0x1234);
  ```
  После преобразования, `p` становится указателем на память по адресу `0x1234`. Однако сам адрес памяти может быть недействительным или указывать на случайные данные.
- **Особенности**:
  - Позволяет интерпретировать битовое представление одного типа как другого.
  - Используется с осторожностью, так как может привести к неопределённому поведению.

### const_cast
- **Что делает `const_cast`?**  
    Убирает или добавляет модификатор `const` (и/или `volatile`) у указателей или ссылок.
    - **Синтаксис**
		`const_cast<тип-назначения>(выражение);`
		- **`тип-назначения`** — это новый тип, который вы хотите получить.
		- **`выражение`** — это значение, которое вы преобразуете.
    
- **Когда использовать?**
    - При необходимости вызвать функцию, которая ожидает неконстантный параметр, но у вас есть константный объект.
    ```cpp
	#include <iostream>
	void modify(int& value) {
	    value = 100;
	}
	
	int main() {
	    int x = 42; // Объявлен без const
	    const int& ref_x = x; // ref_x имеет квалификатор const
	
	    modify(const_cast<int&>(ref_x)); // Удаление const, корректно
	    std::cout << "x = " << x << '\n'; // Вывод: x = 100
	    return 0;
	}
    ```
    > Здесь поведение определено, так как исходный объект `x` не является `const`.
    
- **Когда НЕ использовать?**
    
    - Если вы пытаетесь изменить изначально `const` объект — это всегда приводит к неопределённому поведению.
    ```cpp
    #include <iostream>
int main() {
    const int x = 42;
    int* p = const_cast<int*>(&x);
    *p = 24; // Неправильное использование (неопределённое поведение)
    std::cout << x << '\n'; // Результат может быть любым
    return 0;
}
```
> **Почему UB (неопределённое поведение)?**  
> Объект `x` изначально объявлен как `const`, и изменение его значения недопустимо.

```cpp
const int x = 10;
int* p = const_cast<int*>(&x);
*p = 20; // НО: это неопределённое поведение, если x изначально был объявлен как const
```


---
##### 5. Virtual functions, function overloading vs function overriding, usage of virtual functions, examples, pure virtual functions, virtual destructors, exception handling.

## Виртуальные функции

#### Что такое виртуальная функция?
- **Определение**: Если в классе родителе объявлена виртуальная функция, а в классе наследнике она переопределена, то при вызове данной функции через ссылку или указатель родительского типа на объект наследника вызовется функция наследника.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void display() {
          std::cout << "Base class" << std::endl;
      }
  };

  class Derived : public Base {
  public:
      void display() override {
          std::cout << "Derived class" << std::endl;
      }
  };

  int main() {
      Base* basePtr = new Derived();
      basePtr->display(); // Вывод: Derived class
      delete basePtr;
  }
  ```
- **Особенности**:
  - Вызов функции определяется во время выполнения (runtime polymorphism).
  - Базовый класс должен иметь виртуальный деструктор, чтобы избежать утечек памяти.

---

## Перегрузка функций vs Переопределение функций

#### Перегрузка функций (Function Overloading)
- **Определение**: Перегрузка функций — это создание нескольких функций с одним и тем же именем, но с разными параметрами.
- **Пример**:
  ```cpp
  void print(int i) {
      std::cout << "Integer: " << i << std::endl;
  }
  void print(double d) {
      std::cout << "Double: " << d << std::endl;
  }
  ```
- **Особенности**:
  - Происходит на этапе компиляции.
  - Различается по сигнатурам функций.

#### Переопределение функций (Function Overriding)
- **Определение**: Переопределение — это предоставление новой реализации функции в производном классе.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void show() {
          std::cout << "Base show" << std::endl;
      }
  };
  class Derived : public Base {
  public:
      void show() override {
          std::cout << "Derived show" << std::endl;
      }
  };
  ```
- **Особенности**:
  - Используется ключевое слово `virtual` в базовом классе.
  - Производный класс может дополнительно использовать `override` для явного указания переопределения.

---

## Использование виртуальных функций

- **Основные случаи применения**:
  - Создание интерфейсов или базовых классов для наследования.
  - Реализация полиморфизма для обработки объектов различных типов через общий интерфейс.

*Пример*
```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Some generic animal sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {
        std::cout << "Woof!" << std::endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        std::cout << "Meow!" << std::endl;
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->sound(); // Вывод: Woof!
    a2->sound(); // Вывод: Meow!

    delete a1;
    delete a2;
}
```

---

## Чисто виртуальные функции (Pure Virtual Functions)
- **Определение**: Чисто виртуальная функция — это функция, объявленная в базовом классе, которая не имеет реализации и должна быть реализована в производных классах.
- **Синтаксис**:
  ```cpp
  virtual void functionName() = 0;
  ```
- **Пример**:
  ```cpp
  class Shape {
  public:
      virtual void draw() = 0; // Чисто виртуальная функция
  };

  class Circle : public Shape {
  public:
      void draw() override {
          std::cout << "Drawing Circle" << std::endl;
      }
  };

  class Square : public Shape {
  public:
      void draw() override {
          std::cout << "Drawing Square" << std::endl;
      }
  };
  ```

---

## Виртуальные деструкторы

- **Определение**: Виртуальный деструктор позволяет корректно освобождать ресурсы производных классов через указатели на базовый класс.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual ~Base() {
          std::cout << "Base destructor" << std::endl;
      }
  };

  class Derived : public Base {
  public:
      ~Derived() {
          std::cout << "Derived destructor" << std::endl;
      }
  };

  int main() {
      Base* obj = new Derived();
      delete obj;
      return 0;
  }
  ```
- **Вывод**:
  - Сначала вызывается деструктор `Derived`.
  - Затем вызывается деструктор `Base`.

---

## Обработка исключений (Exception Handling)

### Что такое исключения?
- **Определение**: Исключения используются для обработки ошибок или неожиданных ситуаций в программе.

*Синтаксис*
```cpp
try {
    // Код, который может вызвать исключение
} catch (Type& e) {
    // Обработка исключения
} catch (...) {
    // Ловит любые исключения
}
```

*Пример*
```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 2) << std::endl;
        std::cout << divide(10, 0) << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
```

**Особенности**
- Используйте исключения для критических ошибок.
- Не рекомендуется бросать исключения в конструкторах или деструкторах.



