
##### 1. C++ Basics: References, Pointers, Memory Segments, and Operators

### References and pointers

| **`*` (Указатели)**          | **`&` (Ссылки и адреса)**                |
| ---------------------------- | ---------------------------------------- |
| `int *x;`                    | `int &x = y;`                            |
| **Указатель** на переменную. | **Ссылка** на переменную.                |
| `int *x = new int{5};`       | `int y = 10;`                            |
| `std::cout << *x;`           | `&y;` (Получение адреса переменной `y`). |
| **Разыменование** указателя. | **Адрес** переменной.                    |

```cpp
int x = 5;       // Объявление переменной x и инициализация значением 5
int& y = x;      // Ссылка y на переменную x
int* ptr = &x;   // Указатель ptr, указывающий на адрес переменной x
```
+---------+         +---------+
|   x, y  | ----->  |    5    |  // Значение 5
+---------+         +---------+
      ^
      |
+---------+
|   ptr   | ----->  // Указывает на адрес x
+---------+


- **Ссылка**: Это алиас (другое имя) для переменной. Ссылка должна быть инициализирована и не может быть null.
    ```cpp
    int x = 5; 
	int& ref = x; // ref — это ссылка на x
    ```
- **Указатель**: Переменная, которая хранит адрес памяти другой переменной.
    ```cpp
    int x = 10;
    int* ptr = &x; // ptr stores the address of x
    *ptr; // Dereferencing
    ptr = nullptr; // Null pointer
```
 
	
```cpp
void f(int* &p) { 
    // Используем &, чтобы передать ptr в функцию по ссылке, p станет другим именем для ptr
    p = new int{5}; // В heap создается участок памяти типа int со значением 5
                    // После возврата из функции p исчезнет, но ptr в main останется
	}
	int main() {
	    int* ptr;
	    f(ptr);        
	    std::cout << *ptr; // 5        
	    return 0;
	    }	
```

```cpp
// если переменная уже объявлена
int* x = new int{5};

std::cout << * x;  // dereference (обращение к куску памяти, на который ссылается, указывает переменная)
```
  
- если создать переменную и писать * слева от имени переменной - это **указатель**  
- если создать переменную и слева писать & - это **ссылка**  
- если переменная УЖЕ создана и писать * слева от имени переменной - это **dereference** 
- переменная УЖЕ создана и слева писать & - это **адрес** данной переменной

```cpp
int y = 10;
int* x = &y; (так как * стоит при создании переменной - это указатель
              так как y уже создан, то & - это не референс, а адрес
              то есть х есть указатель на у)
```

```cpp
void f(int* &p) { 
    *p = 5 // т.к p - это другое имя для ptr и мы не знаем на какой адрес ptr указывало (а этот кусок памяти может вообще быть не из нашей программы), то так писать НЕЛЬЗЯ
}

int main()
{
    int* ptr; // ptr - это указатель, но мы не знаем на какой кусок памяти он указывает
    
    f(ptr);
    
    std::cout << * ptr; //5

    return 0;
}
```

```cpp
void f(int* &p) { 
    int x = 5;
    p = &x;
}
// если так написать, то после возвращения из функции переменная х удалится и это может привести к undefined behavior

int main()
{
    int* ptr; // ptr - это указатель, но мы не знаем на какой кусок памяти он указывает
    
    f(ptr);
    
    std::cout << * ptr; //5

    return 0;
}
```
 
### Сегменты памяти: Stack и Heap
- **Стековая память (Stack)**: Автоматически выделяется и освобождается. Используется для локальных переменных и вызовов функций.
- **Куча (Heap)**: Память выделяется динамически с помощью `new` и освобождается с помощью `delete`.
    ```cpp
	int* p = new int(10); // Память выделяется в куче
	delete p;             // Память освобождается

    ```

### Function Overloading and Default Parameters
**Function Overloading**
***когда несколько функций имеют одинаковое имя, но различное число или тип аргументов***

**Example:**
```cpp
int add(int a, int b);      // Function that adds two integers

double add(double a, double b); // Function that adds two doubles

int min(int a, int b) {
    return a < b ? a : b;  // тернарный оператор
}

int min(int a, int b, int c){
    return min(min(a,b), c);
}

double min(double a, double b){
    return a < b ? a : b;
}

// кто-то сказал можно и с template, но это на потом

int main() {
    int x;
    int y;
    std::cin >> x >> y;
    std::cout << min(x, y);
    
    int z;
    std::cin >> z;
    std::cout << min(x,y,z);
    return 0;
}
```

***ВАЖНО:***
- НО нельзя проводить перегрузку функций, которые отличаются лишь возвращаемым типом
	```cpp
	int func(int a);
	double func(int a); // Ошибка
	```
	
	могут ли быть две функции с одинаковым названием, с одинаковым числом аргументов, с одинаковым типом аргументов, но с различными возвращаемыми типами  
	  
	ответ:  
	могут:
	- **Ковариантные типы возврата в виртуальных функциях**:
		```cpp
		class Base {
		public:
		    virtual Base* clone() const;
		};
		
		class Derived : public Base {
		public:
		    Derived* clone() const override; // Разный возвращаемый тип
		};
		```
    
- **Шаблонные функции и специализации**:
	```cpp
	template <typename T>
	void bar(T t);
	
	void bar(int x); // Специализация

```
    
- **Разные пространства имен**:
	```cpp
	namespace A { void func(int); }
	namespace B { double func(int); }

```
    
- **Перегрузка оператора вызова функций (`operator()`)**.
    

---

### Параметры по умолчанию
Параметры по умолчанию задаются при объявлении функции. Если аргумент не указан, используется значение по умолчанию.

**Пример:**
```cpp
void greet(const std::string& name = "Guest") {
    std::cout << "Hello, " << name << "!\n";
}

int main() {
    greet();        // Hello, Guest!
    greet("John");  // Hello, John!
    return 0;
}

```

---
**Example of Conflict:**
```
void print(int x, int y = 10); // Function with default parameter
void print(int x);            // Overloaded function

int main() {
    print(5); // Error: Ambiguity, compiler cannot decide which version to call
    return 0;
}
```


### l-value vs r-value
- **l-value**: это то выражение, которое ХОТЬ ОДНАЖДЫ может оказаться слева от знака =.
- **r-value**: это то выражение, которое ЛИШЬ может оказаться справа от знака =.
    ```cpp
    int x = 10;   // x is an l-value, 10 is an r-value 
    int&& r = 20; // r binds to r-value 20
    ```


---
##### достаточное но не необходимое условие, чтобы быть l-value
если у выражения есть имя, то оно 100% l-value
но может не иметь имени и все равно быть l-value, нпр dereference *ptr

```cpp
int postfix(int& x) // эта функция делает то же самое что и х++
{
    int y = x;
    x += 1;
    return y;
}

int prefix(int& x) 
{
    x += 1;
    return x;
}

int main(){
    int x = 10;
    x++; // r-value
    ++x; // l-value
}
```

у каждого выражения в с++ есть **тип, значение и побочный эффект**
например :  
  
1. **x++**  
тип: int  
значение: старое значение х (до инкремента)  
побочный эффект: увеличение на единицу  
  
2. **++x**  
тип: int  
значение: новое значение х (после инкремента)  
побочный эффект: увеличение на единицу

3. **х = y** : l-value  
как проверить? брать и приравнять к чему-то  
  
среди всех бинарных операций оператор = работает справа на лево  
x = y = 15 - сначала приравнивает у, а потом х  
  
4. **x + y**: r-value  
никак не может оказаться слева  
  
! const переменные всегда l-value  
  
обычный reference можно создать только и только на l-value  
а const reference можно


##### 2. Revising OOP in C++,  struct, Member variables and member functions, default constructors, constructors with parameters, operator overloading.

OOP is a programming paradigm that uses objects and classes to model real-world problems. It includes the following core principles:

### Core Concepts

1. **Encapsulation**:  
	(_если спросят на интервью_)  
	это возможность модифицировать доступ к свойствам ваших классов  
	  
	(_исходное определение_)  
	Инкапсуляция позволяет хранить данные и функции, которые работают с этими данными в одной структуре, которая называется классом.
    
2. **Inheritance**:
    
    - Это передача свойств одного класса другому.
    - пример:
      ```cpp
         class Base {     
	    public: 
		    int x;        
		}; 
		class Derived : public Base {     
		public:         
			void show() { std::cout << x; } 
		};
       ```
  

3. **Polymorphism**:
    
	_(в языке)_
	это когда две отдельные сущности имеют одно и то же имя  
	нпр: hot (горячо/остро)  
	  
	_(в с++)_  
	Полиморфизм разделяется на два типа:  
	  
	° **статичный**: происходит compile time  
	нпр: перегрузка функций, шаблоны  
	   
	° **динамичный**: runtime решается какая из функций с одинаковым именем вызывается  
	нпр:
	```cpp
	int n;
	std::cin >> n;
	
	ptr = n % 2 == 0 ? new Base : new Derived;
	
	ptr->f();


	class Base {     
			public:         
				virtual void print() { std::cout << "Base"; } 
			}; 
			
			class Derived : public Base {     
			public:         
				void print() override { std::cout << "Derived"; } 
			};
	```

4. **Abstraction**:
	 Это рассмотрение тех свойств субъекта, которые важны при решении задачи, и отбрасывание остальных свойств.
	нпр: свойства gun в GTA

    Класс называется **абстрактным**, если в нем есть хотя бы одна чисто виртуальная функция.
	**свойства абстрактного класса:**  
	1. нельзя создать объект абстрактного класса  
	2. если класс унаследован от абстрактного класса и не делает override всех абстрактных (чисто виртуальных) функций, то он тоже **абстрактный**. 

	Класс, в котором присутствует хотя бы одна виртуальная функция, называется **полиморфным** классом

---
### Structs in C++
```cpp
#include <iostream>
#include <cmath>

// Структура есть множество данных (которое называется полем структуры)
// и множество функций (называются member functions или методы структуры), которые работают с этими данными.
struct Complex
{
    //---------------------------------------------------------  Поле структуры:  -----------------------------------------------------------

    double re;
    double im;
    
    После объявления вне структуры (например в main)
        Complex z;
    по сути мы объявим сразу 2 переменные - z.re и z.im
    С ними мы можем делать все действия, которые делали бы с переменными типа double, например:
        int main()
        {
            Complex z;
            z.re = 5.23;
            z.im = ze.re - 2;
            std::cout << z.re << " " << z.im;
        }
    Переменные с типом какой-то структуры называются объектами (например z-объект).
    

    //--------------------------------------------------------- Методы структуры: -----------------------------------------------------------

    double abs() const
    {
        return std::sqrt(re * re + im * im);
    }
    
        Данная функция вычисляет абсолютное значение комплексного числа.
        Обращемся к нему через какой-то объект, например z.abs();

        const - гласит, что данный метод не будет менять поле структуры, т.е. значения re и im не поменяются.
        Если метод небыл бы константным, то его нельзя было бы вызвать из константного объекта, например запись

        void printAbs(const Complex& complex)
        {
            std::cout << complex.abs();
        }

        не скомпилировалась бы, если бы функция abs небыла бы объявлена через const 
        (так как ссылка на объект complex константная).
    

    void add_real(double real)
    {
        re += real;
    }
    
        Данная функция прибавляет к вещественной части нашего комплексного числа другое вещественное число.
        Обращемся к нему через какой-то объект и передаем число, например z.add_real(3.14);

        Заметим, что данная функция не может являтся константной, если попытаться написать в его объявлении
            void add_real(double real) const
        код не скомпилируется, так как мы меняем состояние поля структуры на 51ой строке.
    

    //----------------------------------------------------------- Конструкторы: -------------------------------------------------------------

    
        Конструктор вызывается при создании объекта. 
        Конструктор - это функция, у которого нету возвращаемого типа (даже void), а имя совпадает
        с именем самой структуры. Например:
        
            // конструктор (1)
            Complex(double real_part)
            {
                 re = real_part;
                 im = 0;
            }

        Чтобы вызвать данный конструктор, необходимо при инициализации объекта передать вещественное число.
        Например:

            int main()
            {
                 Complex z1(23.5);
                 Complex z2 = -2.4;
            }

        После записи на 81ой строке вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
        После записи на 82ой строке вызовется конструктор(1) и будет создан объект z2 с полем re = -2.4, im = 0.

        ЗАМЕЧАНИЕ 1: Если рядом с объявлением конструктора написать ключегое слово explicit, т. е.
            explicit Complex(double real_part)
        запись на 82ой строке не скомпилируется.
        Данная запись нужна, если мы хотим вызывать конструктор лишь явным образом, а в 82ой строке она вызвана неявно.

        ЗАМЕЧАНИЕ 2: Одновременно может существовать несколько конструкторов, если они отличаются аргументами. Например
        наряду с конструктором (1) можно объявить другой конструктор

            // конструктор (2)
            Complex(double real_part, double imaginary_part)
            {
                 re = real_part;
                 im = imaginary_part;
            }

        Конструктор 2 вызовется если передать при создании объекта сразу 2 вещественных числа. Например
            int main()
            {
                 Complex z1(23.5);
                 Complex z2(-2.4, 9.5);
            }
        После записи на 106ой строке вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
        После записи на 107ой строке вызовется конструктор(2) и будет создан объект z2 с полем re = -2.4, im = 9.5.
    

    //----------------------------------------------------- Конструктор по умолчанию: -------------------------------------------------------

    
        Конструктор, который не получает никаких аргументов называется конструктором по умолчанию (default constructor).
        Например:

            // конструктор (3)
            Complex()
            {
                 re = 0;
                 im = 0;
            }

        Данный конструктор вызывается, если при создании объекта аргументов передано небыло, например:

            int main()
            {
                 Complex z;
            }
        
        ЗАМЕЧАНИЕ 1: Если в структуре нету никаких конструкторов, то компилятор генерирует собственный конструктор по умолчанию.
        ЗАМЕЧАНИЕ 2: Если в структуре присутствует хоть 1 конструктор, то конструктор по умолчанию не генерируется. 
        Так например, если объявить лишь конструкторы (1) и (2), то запись на 130 строке не скомпилируется. 
        В ином случае, если никаких конструкторов не объявлено, то компиляция пройдет успешно.

        ЗАМЕЧАНИЕ 3: Конструкторы (1), (2) и (3) можно объединить в 1:
            
            // конструктор (4)
            Complex(double real_part = 0, double imaginary_part = 0) 
            {
                re = real_part;
                im = imaginary_part;
            }

    

    //------------------------------------------------------ Member initialization: ---------------------------------------------------------
    // конструктор (5)
    Complex(double real_part = 0, double imaginary_part = 0) 
        : re(real_part)
        , im(imaginary_part) 
    {
    }
    
        Данная запись отличается от конструктора (4) тем, что значения переменным re и im в (4) задаются уже после их создания.
        То что происходить в конструкторе (4) эквивалентно следующему:
             double re;
             double im;
             re = real_part;
             im = imaginary_part;
        а в конструкторе (5) происходит следующее:
             double re = real_part;
             double im = imaginary_part;
        т.е. значения в этом случае задаются при создании re и im.
    */

    //------------------------------------------------------ Перегрузка операторов: ---------------------------------------------------------

    Complex& operator+=(const Complex& other)
    {
        re += other.re;
        im += other.im;

        return *this;
    }

    Complex& operator-=(const Complex& other)
    {
        re -= other.re;
        im -= other.im;

        return *this;
    }

    Complex& operator*=(const Complex& other)
    {
        re = re*other.re - im*other.im;
        im = re*other.im + im*other.re;

        return *this;
    }

    Complex& operator/=(const Complex& other)
    {
        // сделай сам

        return *this;
    }

    //------------------------------------------------------ Другие операторы: ---------------------------------------------------------

};  //<------------------------------------------- Заметте, структура заканчивается записью ;

//------------------------------------------------------ Операторы вне структуры: ---------------------------------------------------------

Complex operator+(Complex lhs, const Complex& rhs)
{
    return lhs += rhs;
}

Complex operator-(Complex lhs, const Complex& rhs)
{
    return lhs -= rhs;
}

Complex operator*(Complex lhs, const Complex& rhs)
{
    return lhs *= rhs;
}

Complex operator/(Complex lhs, const Complex& rhs)
{
    return lhs /= rhs;
}

//------------------------------------------------------ Операторы << и >>: ---------------------------------------------------------

std::ostream& operator<<(std::ostream& out, const Complex& complex)
{
    out << "(" << complex.re << ", " << complex.im << ")";

    return out;
}

int main()
{
}

```

---
##### 3. Function/class templates, Basic implementation of a fixed size array in C++, destructor, copy constructor, assignment operator, private/public/protected, classes, class vs struct, const member functions.

```cpp
#pragma once
#include <cstddef>
#include <iostream>
#include <string>

В данном файле объясняются
1. Функции template
2. Классы template
3. Отделение интерфейса от реализации для темплейт классов
4. Реализация мув конструктора и оператора присваивания

Допустим мы хотим создать функцию, которая печатает переданное значение.
Пример:
void print(int x)
{
   std::cout << x << "\n";
}
Отлично! При вызове print(777); будет напечатано 777, но что если надо также уметь печатать строки?
Разумеется если сейчас вызвать print("Hello World!"); будет ошибка компиляции. Поэтому мы решаем использовать
перегрузку функций.
void print(std::string str)
{
   std::cout << str << "\n";
}
Теперь если вызвать print(777); вызовется первая функция, а если вызвать print("Hello World!"); вторая.
Но что если мы попытаемся вызвать print('c'); ? Ведь 'c' char и для этого типа нет соответствующей функции.
Вот мы и создаем еще одну функцию
void print(char c)
{
   std::cout << c << "\n";
}

--------> [ВОПРОС] Для каких еще типов надо определить данную функцию?
Ответ: Как раз для таких случаев и созданы функции-шаблоны (function templates).
Синтаксис определения функции-шаблона (function template) следующий

template <typename «Название Типа» >
«определение функции»

Например:

template <typename T>
void print(T value)
{
   std::cout << value << "\n";
}

Но данную функцию можно улучшить, так как нам ненужна копия передаваемого значения для печатания
пусть функция получает данное значение по константной ссылке 
template <typename T>
void printValue(const T& value)
{
   std::cout << value << "\n";
}

В данный момент printValue не является функцией, а является шаблоном.
На его основе создаются функции.

Например: Если вызвать где-нибудь в коде printValue(777); тогда во время компиляции автоматически будет создана функция

void printValue(const int& value) // T=int, так как 777-это int.
{
   std::cout << value << "\n";
}

А если вызвать где-нибудь еще printValue("Hello World!") тогда также будет создана функция

void printValue(const char*& value) // T=char*, так как тип "Hello World!" - это char*
{
   std::cout << value << "\n";
}

Замечание: Если же еще где-то вызвана функция printValue(12345); новой функции создано не будет, а будет вызвана
функция созданная на строке 61.

Созданные функции называются template functions.
Подытожим: То что было создано на строке 51 называется function template, и это не функции, а шаблоны,
а то, что было создано на строках 61 и 68 - template function, и это уже функции.

-------->[ВОПРОС] А что если мы хотим передать "Hello World" не как char*, а как std::string?
Ответ: Вот функция, в которой передает "Hello World" как строку функции printValue несколькими способами
void pass_hello_world_as_string()
{
   -------------->[СПОСОБ 1]
   std::string str{"Hello World"}; // Напрямую создать std::string и передать.
   printValue(str);

   -------------->[СПОСОБ 2]
   printValue<std::string>("Hello World"); // Тут значение T в printValue вручную определяется как T=std::string.
   Подробно: На самом деле название фенерируемой функции не просто printValue, а printValue<T>
   Вызывая printValue<std::string>, мы как-бы вручную говорим, что T=std::string и не позволяем
   компилятору дедуцировать тип "Hello World" как char*, а заставляем сгенерировать функцию

   void printValue(const std::string& value);

   И сконвертировать "Hello World" в std::string.


   -------------->[СПОСОБ 3]
   Использовать std::string_literals. Делается это так:
   using namespace std::string_literals; // После данной комманды, если написать s после ковычек, тогда тип текста
   в ковычках уже будет не типа char*, а будет типа std::string.
   printValue("Hello World"s); // Заметим, что после "Hello World" написано s, значит будет иметь тип std::string.
}

В FixedSizeArray.h мы объявили массив типа int. Но что если мы хотим уметь создавать массивы любых типов?
Для такого случая и созданы классы-шаблоны (class templates). Определяются они почти тем же способом
как и функции-шаблоны.

template <typename T>
class FixedSizeArray
{
private:
   T* m_arr;           
   std::size_t m_size;

public:
   FixedSizeArray(std::size_t size);

   FixedSizeArray(std::size_t size, T val);

   std::size_t size() const;

   T& operator[](std::size_t index);

   const T& operator[](std::size_t index) const;

   ~FixedSizeArray();

   FixedSizeArray(const FixedSizeArray& other);

   FixedSizeArray(FixedSizeArray&& other);

   FixedSizeArray& operator=(const FixedSizeArray& other);

   FixedSizeArray& operator=(FixedSizeArray&& other);
};

template <typename T>
std::size_t FixedSizeArray<T>::size() const
{
   return m_size;
}

template <typename T>
FixedSizeArray<T>::FixedSizeArray(FixedSizeArray&& other)
   : m_arr(other.m_arr)
   , m_size(other.m_size)
{
   other.m_arr = nullptr;
}

template <typename T>
FixedSizeArray<T>& FixedSizeArray<T>::operator=(const FixedSizeArray<T>& other)
{
   if (this == &other)
      return *this;
   ~FixedSizeArray<T>();

   this->m_arr = new T[other.m_size]{};
   for (std::size_t i = 0; i < other.m_size; ++i)
   {
      this->m_arr[i] = other.m_arr[i];
   }
   this->m_size = other.m_size;

   return *this;
}

template <typename T>
FixedSizeArray<T>& FixedSizeArray<T>::operator=(FixedSizeArray<T>&& other)
{
   if (this == &other)
      return *this;
   ~FixedSizeArray<T>();

   this->m_arr = other.m_arr;
   other.m_arr = nullptr;
   this->m_size = other.m_size;

   return *this;
}

template <typename T>
FixedSizeArray<T>::~FixedSizeArray()
{
   delete[] m_arr;
}

template <typename T>
FixedSizeArray<T>::FixedSizeArray(std::size_t size)
   : m_arr(new T[size]{})
   , m_size(size)
{
}

template <typename T>
FixedSizeArray<T>::FixedSizeArray(std::size_t size, T val)
   : m_arr(new T[size])
   , m_size(size)
{
   for (std::size_t i = 0; i < size; ++i)
   {
      m_arr[i] = val;
   }
}

template <typename T>
FixedSizeArray<T>::FixedSizeArray(const FixedSizeArray& other)
   : m_arr(new T[other.m_size])
   , m_size(other.m_size)
{
   for (std::size_t i = 0; i < m_size; ++i)
   {
      m_arr[i] = other[i];
   }
}

template <typename T>
T& FixedSizeArray<T>::operator[](std::size_t index)
{
   return m_arr[index];
}

template <typename T>
const T& FixedSizeArray<T>::operator[](std::size_t index) const
{
   return m_arr[index];
}

```
---

### Fixed-Size Array Implementation in C++
```cpp
#pragma once
#include <cstddef>


----------->[ВОПРОС] Чем отличается класс от структуры?
Ответ: Класс отличается от структуры лишь двумя вещами.
1. Все мемберы класса (как переменные так и функции) в структуре доступны
повсеместно если ничего другого не писать (все public). В классе наоборот - все мемберы класса
не доступны никому если ничего другого не писать (все private).
2. Тип наследования от структуры - public, а тип наследования от класса - private (в этих файлах это не используется).

Интерфейс - всё то, что позволяет общаться с классом вне самого класса
(для нижеопределенного класса - это функции, объявленные под public:)

Хорошей практикой является декларировать мембер функции в одном файле, а имплементировать в другом (Interface Segregation Principle).
В данном файле написаны лишь декларации упомянутых функций, их имплементация может быть найдена в файле FixedSizeArray.cpp.


class FixedSizeArray
{


Если написать внутри класса ключевое слово private: тогда то, что окажется под этим модификатором
доступа станет недоступным нигде, кроме самого класса. Если же писать модификатор доступа public:
то всё то, что под ним окажется станет доступным.

Данный класс обладает двумя переменными - m_arr и m_size с модификатором доступа private, а также
функциями size, operator[], конструкторами и деструктором с модификатором доступа public.


private:
   int* m_arr;
   std::size_t m_size;


   ----------->[ВОПРОС] Почему m_arr и m_size в private?
   Ответ: Так как объект данного класса из себя должен представлять массив фиксированной длины (FixedSizeArray),
   следовательно размер массива на который указывает m_arr должен равнятся значению m_size всегда и повсюду.
   Следовательно мы не хотим, чтобы у человека, который будет использовать наш класс в своих грязных целях
   даже появилась бы мысль поменять значение m_arr или m_size, a даже если бы и появилась бы - то он не смог.

   В общем и целом - модификаторы доступа нужны, чтобы в самом классе не появлялось бы внутренних противоречий.

   ----------->[ВОПРОС] Почему у m_size тип std::size_t?
   Ответ: std::size_t определен в заголовочном файле <cstddef> и представляет из себя неотрицательный целочисленный
   тип, который способен в себе хранить наибольший размер куска памяти, который поддерживается самой системой.
   В 32-битной системе размер std::size_t 32 бита, а в 64-битной системе размер std::size_t 64 бита.
   Его будем использовать для размеров, индексов и количества.



public:

   FixedSizeArray(std::size_t size);

   FixedSizeArray(std::size_t size, int val);

   std::size_t size() const;

   int& operator[](std::size_t index);

   const int& operator[](std::size_t index) const;

   ~FixedSizeArray();

   FixedSizeArray(const FixedSizeArray& other);

};

```

```cpp
Для того, чтобы отделить имплементацию от декларации всю имплементацию
функций переводим в данный .cpp файл, а в .h файле пишем декларации функций.

Сперва инклюднем .h файл, где задекларированы все функции, которые будем имплементировать. 
#include "FixedSizeArray.h"

Если декларация в классе имеет вид
 
«возвращаемый тип» «название функции»(«аргументы»);

То в .cpp файле имплементация функции будет иметь вид

«возвращаемый тип» «название класса»::«название функции»(«аргументы»)
{
    «тело функции»;
}

Например, в .h файле функция size задекларирована как

std::size_t size() const;

а в данном файле она должа иметь нижеприведенный вид,
причем полное название функции size - это FixedSizeArray::size().
std::size_t FixedSizeArray::size() const
{
	return m_size;
}

То, что было сказано для обычных мембер-функций верно и для конструкторов,
т.е. если конструктор задекларирован в .h файле как

«название класса»(«аргументы»)

то ее имплементация будет иметь вид

«название класса»::«название класса»(«аргументы»).
 
Ниже можете видеть пример конструктора, который получает размер массива,
создает сам массив в heap-е, сохранив указатель на первый элемент m_arr,
также сохраняет значение переданного размера в m_size.
FixedSizeArray::FixedSizeArray(std::size_t size)
	: m_arr(new int[size])
	, m_size(size)
{
}

Данный же конструктор принимает 2 аргумента
1. Размер массива
2. Значение, которым надо заполнить все элементы массива
Делает данный конструктор то же самое, что и верхний конструктор,
просто дополнительно проходит по всем элементам созданного массива и 
приравнивает к каждому элементу переданное значение val.
FixedSizeArray::FixedSizeArray(std::size_t size, int val)
	: m_arr(new int[size])
	, m_size(size)
{
	for (std::size_t i = 0; i < size; ++i)
	{
		m_arr[i] = val;
	}
}

О данных двух функциях уже было сказано в .h файле.
Они просто возвращают референс на элемент массива соответствующий индексу.
int& FixedSizeArray::operator[](std::size_t index)
{
	return m_arr[index];
}

const int& FixedSizeArray::operator[](std::size_t index) const
{
	return m_arr[index];
}

В деструкторе просто удаляем массив, на который указывает m_arr.
FixedSizeArray::~FixedSizeArray()
{
	delete[] m_arr;
}

В конструкторе копирования создается новый массив того же размера, что и
массив переданного объекта other, после чего копируется содержание массива other.m_arr
в m_arr.
FixedSizeArray::FixedSizeArray(const FixedSizeArray& other)
	: m_arr(new int[other.m_size])
	, m_size(other.m_size)
{
	for (std::size_t i = 0; i < m_size; ++i)
	{
		m_arr[i] = other[i];
	}
}

```

---

## Destructor, Copy Constructor, and Assignment Operator

#### Destructor
- A special member function used to release resources when an object is destroyed.
```cpp
class MyClass {
public:
	~MyClass() {
		std::cout << "Destructor called" << std::endl;
	}
};
```

#### Copy Constructor
- Creates a new object as a copy of an existing object.
```cpp
class MyClass {
private:
	int value;

public:
	MyClass(int v) : value(v) {}

	// Copy Constructor
	MyClass(const MyClass& other) : value(other.value) {
		std::cout << "Copy Constructor called" << std::endl;
	}
};
```

#### Assignment Operator
- Assigns the values from one object to another after both have been created.
```cpp
class MyClass {
private:
	int value;

public:
	MyClass(int v) : value(v) {}

	// Assignment Operator
	MyClass& operator=(const MyClass& other) {
		if (this != &other) {
			value = other.value;
		}
		std::cout << "Assignment Operator called" << std::endl;
		return *this;
	}
};
```

---

## Access Specifiers: Private, Public, Protected

#### Public
- Members are accessible from outside the class.
```cpp
class MyClass {
public:
	int value;
};
```

#### Private
- Members are accessible only within the class.
```cpp
class MyClass {
private:
	int value;
};
```

#### Protected
- Members are accessible within the class and its derived classes.
```cpp
class Base {
protected:
	int value;
};
```

---
# Classes vs. Structs

- **Class**: Members are private by default.
- **Struct**: Members are public by default.
```cpp
class MyClass {
private:
	int value;
};

struct MyStruct {
public:
	int value;
};
```

---
# Const Member Functions

- Functions that do not modify the state of the object.
```cpp
class MyClass {
private:
	int value;

public:
	MyClass(int v) : value(v) {}

	int getValue() const {
		return value;
	}

	void setValue(int v) {
		value = v;
	}
};
```




##### 4. l-value/r-value references, std::move, move constructor, move assignment operator, Type casting in c++: static_cast, reinterpret_cast, const_cast.
### **l-value и r-value**

```cpp
#include <iostream>
#include <cmath>
#include <string>

// В данной функции объясняется, что такое l-value и r-value выражения, а также характеристики выражений в C++.
void l_value_vs_r_value_and_expression_characteristics()
{
   l-value (или left-value) есть выражение, которое может хотя бы раз оказаться слева от знака =.
   r-value (или right-value) есть выражение, которое может оказаться лишь справа от знака = и не может оказаться слева.
   Например:

   int x = 10;          x - lvalue, так как можно написать x=12;
   const double y = 19; y - lvalue, так как на этой же строке y оказалась слева от знака =.
   8;                   8 - r-value, так как нельзя написать, например, 8=1+3;
   x + 1;               x+1 - r-value, так как нельзя написать, например, x+1=666;
   "Hello World";       "Hello World" - r-value, так как нельзя написать, например "Hello World" = "Goodbye World";

   У всякого выражения в C++ есть 3 характеристики:
   1. Type        (тип)
   2. Value       (значение)
   3. Side-Effect (побочный эффект)

   Примеры характеристик выражений:

   Пример 1.
   {
      double a = 19;
      a + 1; 1. double
             2. 20
             3. Ничего
   }
   Пример 2.
   {
      int a = 7;
      a = 7; 1. int
             2. 7 (так как если напечатать std::cout << (a=7); выведется 7)
             3. Изменить значение a на 7
   }
   Пример 3.
   {
      "Hello World"; 1. char*
                     2. "Hello World"
                     3. Ничего
   }
   Пример 4.
   {
      int a = 15;
      ++a;   1. int
             2. 16 (так как если напечатать std::cout << (++a); выведется 16)
             3. Увеличить значение a на 1
   }
   Пример 5.
   {
      int a = 15;
      a++;   1. int
             2. 15 (так как если напечатать std::cout << (a++); выведется 15)
             3. Увеличить значение a на 1
   }

   Подытожим:
   {
      int a = 15;
      std::cout << ++a << "\n"; Напечатает 16, т.е. новое значение а. <---------------------------------------------
      std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта ++a.    |
   }                            |                                                                                   | Сравните
   {                            |                                                                                   |
      int a = 15;               |                                                                                   |
      std::cout << a++ << "\n"; Напечатает 15, т.е. исходное значение а. <------------------------------------------
      std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта a++.
   }

   Таким образом префиксный инкремент и постфикстный инкремент увеличивают переменную на 1,
   но значение префиксного инкремента - новое значение переменной после увеличения,
   а значение постфиксного инкремента - исходное значение переменной до увеличения.
   
   Кроме того:
   ++x; l-value, так как можно написать, например, ++x=12; <---Значение х поменяется на 12.
   x++; r-value, так как нельзя написать, например, x++=12; <---Ошибка компиляции.

   ЗАМЕЧАНИЕ: Всё у чего есть имя l-value, но всё у чего нет имени ещё не значит, что r-value.
             Достаточным условием того, что какое-то выражение было l-value, является существование имени для этого выражения.
   Например: 
             1. x;   x-название переменной => оно точно l-value.
             2. ++x; ++x не название переменной, но это всё ещё l-value.
             3. x++; x++ не название переменной, но в этот раз это r-value.

   Другие примеры l-value выражений:
   x = y;
   x += 1;
   x = x * 20;
   --x;

   Другие примеры r-value выражений:
   x + 1;
   std::abs(x);
   std::sqrt(y);
   10;
   's';
   3.14;
   "This is too an r-value expression";
   x--;
}

void references_and_const_references()
{
   int x = 19;
   int copy = x;

   int& ref = x;

   copy = 777;
   std::cout << x << "\n";
   ref = 777;
   std::cout << x << "\n";

   const int constantInteger = 7;
   const int& constantReference = constantInteger;

   const int& constantReference2 = x;
   const int& constantReference3 = x + 123;
}

void print(std::string str)
{
   std::cout << str;
}

void print1(std::string& str)
{
   std::cout << str;
}

void print2(const std::string& str)
{
   std::cout << str;
}

int main()
{
}


```

```cpp
#include <iostream>

В данной функции объясняется что такое r-value референс.
void r_value_reference()
{
   Будет использовано позже.
   int x = 10;

   Те референсы, которые были обсуждены в файле References.cpp называются l-value референсами
   и они присутствовали в C++ с самого начала его существования.
   
   Называются они l-value референсами так как неконстантные референсы могут ссылаться лишь на
   l-value выражения. Но как мы уже поняли есть потребность создавать функции,
   которые получали бы l-value значения по-ссылке (чтобь избежат копирования),
   но могли бы также получать r-value значения (см. функцию print2 в References.cpp).
   Именно по-этому было решено разрешать присваивать константным ссылкам как l-value, так и r-value значения.
   
   Но что если по каким-то причинам мы хотим создать отдельно 2 функции с одним и тем же именем,
   так, чтобы первая из них вызывалась бы если было передано l-value значение, а вторая вызывалась
   бы, если было передано r-value значение?
   
   Как раз для этого случая существуют r-value референсы, которые были добавлены в C++11,
   их синтаксис следующий:
   
   <тип>&& <название референса> = <r-value значение>;
   
   Например:
   int&& r_value_ref = x + 1;

   Замечания:
   1. r-value референс может ссылаться лишь на r-value значение (удлинняя жизнь временной переменной).
      т.е. запись int&& ref=x; привела бы к ошибке компиляции, так как х - l-value.
   2. r-value референсы как и l-value референсы должны быть инициализированны, т.е. нельзя писать
      int&& ref; <---- Ошибка компиляции.

   --------->[ВОПРОС] Как уже было сказано r-value референс может ссылаться лишь на r-value значение,
                      но сам этот референс представляет из себя нечто l-value или r-value?
                      То есть может ли он оказаться слева от знака =?
   Ответ: Так как у r_value_ref есть имя, то оно является l-value, как уже было сказано в References.cpp
   Подытожив: r_value_ref может ссылаться лишь на r-value значение, но сам r_value_ref - l-value.
   Пример: Можно менять значение r-value референса
   r_value_ref = 19;
   ++r_value_ref;
   r_value_ref /= 10;

   Замечание: Значение константных r-value референсов поменять нельзя и ссылаться они могут
              лишь на r-value выражения. Пример:
   const int&& const_r_value_ref = 10 / x + 3 - r_value_ref;

   --------->[ВОПРОС] На что могут ссылаться константные/неконстантные l-value/r-value референсы?
   Ответ: Смотри таблицу
   
                      |           non-const               |                const                |
   -------------------|-----------------------------------|-------------------------------------|
    l-value reference | only non-const l-value expression | any l-value and r-value expression  |
   -------------------|-----------------------------------|-------------------------------------|
    r-value reference |     only r-value expression       |      only r-value expression        | 
   -------------------|-----------------------------------|-------------------------------------|
   
}

Далее приводятся примеры функций, принимающих l-value и r-value референсы.

void f(int& x) // принимает неконстантный l-value референс.
{
   std::cout << "x was l-value\n";
}

void f(int&& x) // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   f(var);
   f(var + 1);
   f(777);
}

То на 78-ой строке вызовется первая функция,
а на 80-ой и 81-ой строке вызовется вторая и будет напечатано

x was l-value
x was r-value
x was r-value

Всё из-за того, что
1. На 79-ой строке аргумент переданный функции является l-value и будет вызвана первая функция
2. На 80-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция
3. На 81-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция

Другой пример с константным l-value референсом:
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   g(var);
   g(var + 1);
   g(777);
}

-------->[ВОПРОС]: И первая и вторая функция могут принимать r-value значения,
                   Так какая из них вызовется на 114-ой и 115-ой строках?
Ответ: Как ни странно - приоритет получения r-value значений дается именно r-value референсам.
        Таким образом мы увидим тот же результат, что и для f:

        x was l-value
        x was r-value
        x was r-value

-------->[ВОПРОС]: Чем отличаются функции g и f?
Ответ: Нельзя передать f константную переменную, например
      
        const int val = 777;
        f(val);

        Не скомпилируется, так как
        1. f на 64-ой принимает неконстантную ссылку, следовательно нельзя передать константное.
        2. f на 69-ой строке принимает r-value референс, следовательно нельзя передать l-value.
        а val константное l-value значение.

        С другой стороны f можно поменять на g в 131-ой строке и компиляция пройдет.

-------->[ВОПРОС]: Что изменилось бы если в 69-ой и 103-ей строках r-value референсы были константными, т.е.
                   void f(const int&& x)
                   void g(const int&& x)
Ответ: Всё что было сказано до этого не изменилось бы. Единственное отличие было бы в том,
        что внутри самих функций x нельзя было бы поменять.

-------->[САМЫЙ ВАЖНЫЙ ВОПРОС]: Для чего это всё нужно?
Ответ: Нужно всё для того, чтобы изменить поведение функции в зависимости от того было ли
        переданно данной функции l-value или r-value, а надобность этого будет понятна
        после прочтения MoveSemantics.cpp.

```

---

### **std::move**

```cpp
#include <iostream>
#include <utility>
#include <string>

В данном файле мы поверхностно поймем, что такое move-семантика.

Рассмотрим следующий сценарий: Есть функция, которая принимает std::string по значению
void f(std::string str)
{
   какие-то действия с str.
}

Заметим, что при следующей передаче переменной функции

int main()
{
   std::string name="Barak Obama";
   f(name);
}
  
Переменная name будет скопирована в str.

Подытожим: В 17ой строке будет создана переменная name
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

А в 18ой строке name будет скопирован в str функции f и будем иметь
 _______________         _______________
|     name      |       |      str      |
|---------------|       |---------------|
| "Barak Obama" |       | "Barak Obama" |
 ---------------         ---------------

-------->[ВОПРОС] А что делать если переменная name нам в main уже ненужна?
                  Ведь тогда логично было бы не создавать копию name, а просто "передать"?
Ответ: Если функцию f изменить нельзя - как раз для этого используется std::move.
       Если написать
 
       int main()
       {
          std::string name="Barak Obama";
          f(std::move(name));
       }

       тогда name не будет скопирован в str, а будет "сдвинут" str.

Подытожим: В 45ой строке будет создана переменная name
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

А в 46ой строке значение name будет мувнуто в str
 _________________         _______________
|       name      |       |      str      |
|-----------------|       |---------------|
| пустое значение |       | "Barak Obama" |
 -----------------         ---------------

Таким образом значение name не будет скопировано, но будет использоваться в str.
Для ясности: "Barak Obama" сохраняется при помощи указателя и вместо того,
             чтобы скопировать саму строку - копируется лишь указатель, а старый указатель
             стирается, то есть:
1. Сперва создается переменная name

 ______
| name |
|------|
|   -----------------> "Barak Obama"   
 ------

 2. При создании переменной str копируется лишь адрес строки, а указатель в name стирается

                     _____
                    | str |
                    |-----|
                    |  |  |
                     --|--
                       |
                       |
 ______                 |
| name |                |
|------|                v
|      |               "Barak Obama"
 ------

---------->[ЗАМЕЧАНИЕ] После std::move переменной name пользоваться нельзя, непонятно какое значение
                       внутри name, что приводит к undefined behavior.

Поймём как работает std::move.

Снова вернемся к примеру из R-valueReferences.cpp
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

------>[ВОПРОС] Что если у нас есть переменная int val=555; и мы хотим передать его
                функции g, но хотим, чтобы вызвалась не функция на строке 99, а на 104?
                Причем мы не хотим менять сами функции.
Очень Странный Ответ: Использовать std::move, а именно

       int val = 555;
       g(std::move(val)); // напечатает "x was r-value"

------>[ВОПРОС] Что же делает std::move? Почему это работает так?
Ответ: Единственная функция std::move - полученное l-value значение преобразовать в r-value.
       Как раз поэтому на строке 114 вызовется функция с строки 104, хоть val и l-value.

------>[ВОПРОС] А как же тогда всё работает для std::move(name) из строки 46?
Ответ: std::string имеет 2 конструктора. Первый из них - это copy-constructor, который принимает l-value reference.
       
       string(const string& other);

       Данный конструктор копирует всю строку other в создаваемый объект.
       Второй же конструктор принимает r-value reference.

       string(string&& other);

       И копирует лишь указатель строки other в создаваемый объект, далее стирает указатель other (именно поэтому тут не const).
       
       Таким образом, вернувшись к функции f, если переменная была передана ей не используя std::move, т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(name);
       }
       То для name будет вызван copy-constructor, так как name l-value и вызовется конструктор на строке 123.

       Если же перед передачей сделать std::move(name), т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(std::move(name));
       }
       Тогда из-за того, что std::move(name) r-value вызовится конструктор, принимающий r-value reference на строке 128.
       Конструктор на строке 128 называется мув конструктором.

```
- **Определение**: `std::move` — это функция, которая преобразует l-value в r-value, позволяя передать временный объект в функции или конструкторы перемещения.
- **Пример**:
  ```cpp
  std::string str = "Hello";
  std::string movedStr = std::move(str); // str теперь пустой
  ```
- **Особенности**:
  - После вызова `std::move` исходный объект теряет свои данные (но остаётся валидным).
  - Используется для оптимизации копирования больших объектов.

---

## **Конструктор перемещения (move constructor)**

- ***Определение***: Конструктор перемещения позволяет передавать ресурсы (например, динамическую память) от одного объекта к другому без копирования.
- *Синтаксис:
  ```cpp
  class MyClass {
  private:
	  int* data;

  public:
	  MyClass(int value) {
		  data = new int(value);
	  }

	  // Конструктор перемещения
	  MyClass(MyClass&& other) noexcept : data(other.data) {
		  other.data = nullptr; // Обнуляем указатель в исходном объекте
	  }

	  ~MyClass() {
		  delete data;
	  }
  };
  ```
- **Особенности**:
  - Конструктор перемещения вызывается, если объект передаётся как r-value.

---

### Оператор присваивания с перемещением (move assignment operator)

- ***Определение***: Оператор перемещающего присваивания используется для переноса ресурсов между объектами.
- *Синтаксис*:
  ```cpp
  MyClass& operator=(MyClass&& other) noexcept {
	  if (this != &other) {
		  delete data;
		  data = other.data;
		  other.data = nullptr;
	  }
	  return *this;
  }
  ```
- **Особенности**:
  - Необходимо очищать текущие ресурсы перед переносом.
  - Обеспечивает защиту от самоприсваивания.

---

# Приведение типов в C++ (type casting in c++)

### static_cast
- **Определение**: Используется для проверяемого преобразования типов во время компиляции. Преобразует, если существует логическая связь и преобразование не приводит к потери данных.

- **Пример**:
  ```cpp
  double d = 3.14;
  int i = static_cast<int>(d); // Убрана дробная часть
  ```
- **Особенности**:
  - Используется для приведения указателей между базовым и производным классами.

### reinterpret_cast
- **Определение**: 
  Это низкоуровневое преобразование, которое **не меняет содержимое памяти**. Оно просто интерпретирует её как другой тип. Используется для небезопасного преобразования типов. Если мы уверены, что преобразование не приведёт к undefined behavior, то можем сделать этот каст. В отличие от других видов приведения (`static_cast`, `const_cast`), `reinterpret_cast` чаще всего используется для низкоуровневых преобразований, связанных с указателями, функциями и значениями.
  
-  **Синтаксис**
```cpp
reinterpret_cast<тип-назначения>(выражение);
```
- **`тип-назначения`** — это тип, в который нужно преобразовать объект.
- **`выражение`** — это значение, которое нужно преобразовать.

- **Пример**:
  ```cpp
  int* p = reinterpret_cast<int*>(0x1234);
  ```
  После преобразования, `p` становится указателем на память по адресу `0x1234`. Однако сам адрес памяти может быть недействительным или указывать на случайные данные.
- **Особенности**:
  - Позволяет интерпретировать битовое представление одного типа как другого.
  - Используется с осторожностью, так как может привести к неопределённому поведению.

### const_cast
- **Что делает `const_cast`?**  
    Убирает или добавляет модификатор `const` (и/или `volatile`) у указателей или ссылок.
    - **Синтаксис**
		`const_cast<тип-назначения>(выражение);`
		- **`тип-назначения`** — это новый тип, который вы хотите получить.
		- **`выражение`** — это значение, которое вы преобразуете.
    
- **Когда использовать?**
    - При необходимости вызвать функцию, которая ожидает неконстантный параметр, но у вас есть константный объект.
    ```cpp
	#include <iostream>
	void modify(int& value) {
	    value = 100;
	}
	
	int main() {
	    int x = 42; // Объявлен без const
	    const int& ref_x = x; // ref_x имеет квалификатор const
	
	    modify(const_cast<int&>(ref_x)); // Удаление const, корректно
	    std::cout << "x = " << x << '\n'; // Вывод: x = 100
	    return 0;
	}
    ```
    > Здесь поведение определено, так как исходный объект `x` не является `const`.
    
- **Когда НЕ использовать?**
    
    - Если вы пытаетесь изменить изначально `const` объект — это всегда приводит к неопределённому поведению.
    ```cpp
    #include <iostream>
int main() {
    const int x = 42;
    int* p = const_cast<int*>(&x);
    *p = 24; // Неправильное использование (неопределённое поведение)
    std::cout << x << '\n'; // Результат может быть любым
    return 0;
}
```
> **Почему UB (неопределённое поведение)?**  
> Объект `x` изначально объявлен как `const`, и изменение его значения недопустимо.

```cpp
const int x = 10;
int* p = const_cast<int*>(&x);
*p = 20; // НО: это неопределённое поведение, если x изначально был объявлен как const
```


---
##### 5. Virtual functions, function overloading vs function overriding, usage of virtual functions, examples, pure virtual functions, virtual destructors, exception handling.

## Виртуальные функции

#### Что такое виртуальная функция?
- **Определение**: Если в классе родителе объявлена виртуальная функция, а в классе наследнике она переопределена, то при вызове данной функции через ссылку или указатель родительского типа на объект наследника вызовется функция наследника.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void display() {
          std::cout << "Base class" << std::endl;
      }
  };

  class Derived : public Base {
  public:
      void display() override {
          std::cout << "Derived class" << std::endl;
      }
  };

  int main() {
      Base* basePtr = new Derived();
      basePtr->display(); // Вывод: Derived class
      delete basePtr;
  }
  ```
- **Особенности**:
  - Вызов функции определяется во время выполнения (runtime polymorphism).
  - Базовый класс должен иметь виртуальный деструктор, чтобы избежать утечек памяти.

---

## Перегрузка функций vs Переопределение функций

#### Перегрузка функций (Function Overloading)
- **Определение**: Перегрузка функций — это создание нескольких функций с одним и тем же именем, но с разными параметрами.
- **Пример**:
  ```cpp
  void print(int i) {
      std::cout << "Integer: " << i << std::endl;
  }
  void print(double d) {
      std::cout << "Double: " << d << std::endl;
  }
  ```
- **Особенности**:
  - Происходит на этапе компиляции.
  - Различается по сигнатурам функций.

#### Переопределение функций (Function Overriding)
- **Определение**: Переопределение — это предоставление новой реализации функции в производном классе.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void show() {
          std::cout << "Base show" << std::endl;
      }
  };
  class Derived : public Base {
  public:
      void show() override {
          std::cout << "Derived show" << std::endl;
      }
  };
  ```
- **Особенности**:
  - Используется ключевое слово `virtual` в базовом классе.
  - Производный класс может дополнительно использовать `override` для явного указания переопределения.

---

## Использование виртуальных функций

- **Основные случаи применения**:
  - Создание интерфейсов или базовых классов для наследования.
  - Реализация полиморфизма для обработки объектов различных типов через общий интерфейс.

*Пример*
```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Some generic animal sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {
        std::cout << "Woof!" << std::endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        std::cout << "Meow!" << std::endl;
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->sound(); // Вывод: Woof!
    a2->sound(); // Вывод: Meow!

    delete a1;
    delete a2;
}
```

---

## Чисто виртуальные функции (Pure Virtual Functions)
- **Определение**: Чисто виртуальная функция — это функция, объявленная в базовом классе, которая не имеет реализации и должна быть реализована в производных классах.
- **Синтаксис**:
  ```cpp
  virtual void functionName() = 0;
  ```
- **Пример**:
  ```cpp
  class Shape {
  public:
      virtual void draw() = 0; // Чисто виртуальная функция
  };

  class Circle : public Shape {
  public:
      void draw() override {
          std::cout << "Drawing Circle" << std::endl;
      }
  };

  class Square : public Shape {
  public:
      void draw() override {
          std::cout << "Drawing Square" << std::endl;
      }
  };
  ```

---

## Виртуальные деструкторы

- **Определение**: Виртуальный деструктор позволяет корректно освобождать ресурсы производных классов через указатели на базовый класс.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual ~Base() {
          std::cout << "Base destructor" << std::endl;
      }
  };

  class Derived : public Base {
  public:
      ~Derived() {
          std::cout << "Derived destructor" << std::endl;
      }
  };

  int main() {
      Base* obj = new Derived();
      delete obj;
      return 0;
  }
  ```
- **Вывод**:
  - Сначала вызывается деструктор `Derived`.
  - Затем вызывается деструктор `Base`.

---

## Обработка исключений (Exception Handling)

### Что такое исключения?
- **Определение**: Исключения используются для обработки ошибок или неожиданных ситуаций в программе.

*Синтаксис*
```cpp
try {
    // Код, который может вызвать исключение
} catch (Type& e) {
    // Обработка исключения
} catch (...) {
    // Ловит любые исключения
}
```

*Пример*
```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 2) << std::endl;
        std::cout << divide(10, 0) << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
```

**Особенности**
- Используйте исключения для критических ошибок.
- Не рекомендуется бросать исключения в конструкторах или деструкторах.



