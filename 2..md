##### Revising OOP in C++,  struct, Member variables and member functions, default constructors, constructors with parameters, operator overloading.

**OOP** is a programming paradigm that uses objects and classes to model real-world problems. It includes the following core principles:

### Core Concepts

1. **Encapsulation**:  
	(_если спросят на интервью_)  
	это возможность модифицировать доступ к свойствам ваших классов  
	  
	(_исходное определение_)  
	Инкапсуляция позволяет хранить данные и функции, которые работают с этими данными в одной структуре, которая называется классом.
    
2. **Inheritance**:
    
    - Это передача свойств одного класса другому.
    - пример:
    ```cpp
	class Base {     
	public: 
		int x;        
	}; 
	class Derived : public Base {     
	public:         
		void show() { std::cout << x; } 
	};
    ```
  

3. **Polymorphism**:
    
	_(в языке)_
	это когда две отдельные сущности имеют одно и то же имя  
	нпр: hot (горячо/остро)  
	  
	_(в с++)_  
	Полиморфизм разделяется на два типа:  
	  
	° **статичный**: происходит *compile time*  
	нпр: перегрузка функций, шаблоны  
	   
	° **динамичный**: *runtime* решается какая из функций с одинаковым именем вызывается  
	нпр:
	```cpp
	class Base {     
	public:         
		virtual void print() { std::cout << "Base"; } 
	}; 
	
	class Derived : public Base {     
	public:         
		void print() override { std::cout << "Derived"; } 
	};
	```

4. **Abstraction**:
	 Это рассмотрение тех свойств субъекта, которые важны при решении задачи, и отбрасывание остальных свойств.
	 
	 **Пример абстракции:**
	 Вы пользуетесь телефоном, зная его функционал (звонки, камера), но не думаете о том, как он устроен внутри.
	 В C++ абстракция реализуется через:
		1. **Классы и объекты**.
		2. **Интерфейсы** (абстрактные классы).
		3. **Виртуальные функции** и **полиморфизм**.

- Абстрактный класс — это класс, который содержит **хотя бы одну чисто виртуальную функцию**. 
	- нельзя создать объект этого класса
	- но они могут использоваться как базовые классы для наследования
```cpp
#include <iostream>

class Shape {
public:
    virtual void draw() const = 0; // Чисто виртуальная функция
};

class Circle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing Rectangle\n";
    }
};
```

- **Виртуальная функция** — это функция, объявленная в базовом классе с ключевым словом `virtual`, которая может быть переопределена в производных классах. Она позволяет реализовать полиморфизм (динамическое связывание).

- Если базовый класс имеет виртуальную функцию, вызов функции через указатель/ссылку на базовый класс будет вызывать **реализацию из производного класса**.
- Если функция не переопределена, используется реализация из базового класса.
```cpp
#include <iostream>
class Base {
public:
    virtual void show() const {
        std::cout << "Base show\n";
    }
};

class Derived : public Base {
public:
    void show() const override {
        std::cout << "Derived show\n";
    }
};

int main() {
    Base* basePtr;
    Derived d;
    basePtr = &d;

    basePtr->show(); // Вывод: Derived show (динамическое связывание)
    return 0;
}
```



---
### Structs in C++

 **Структура** есть множество данных (которое называется полем структуры)
 и множество функций (называются member functions или методы структуры), которые работают с этими данными.
 ```cpp
 struct Complex
{
    //----------------------  Поле структуры:  -------------------------------
    double re;
    double im;
    
    После объявления вне структуры (например в main)
        Complex z;
    по сути мы объявим сразу 2 переменные - z.re и z.im
    С ними мы можем делать все действия, которые делали бы с переменными типа double, например:
	int main()
	{
		Complex z;
		z.re = 5.23;
		z.im = ze.re - 2;
		std::cout << z.re << " " << z.im;
	}
```
Переменные с типом какой-то структуры называются **объектами** (например z-объект).

```cpp
//--------------------------- Методы структуры: -----------------------------

    double abs() const
    {
        return std::sqrt(re * re + im * im);
    }
```
Данная функция вычисляет абсолютное значение комплексного числа.
Обращемся к нему через какой-то объект, например z.abs();

`!` const - гласит, что данный метод не будет менять поле структуры, т.е. значения re и im не поменяются.
Если метод небыл бы константным, то его **нельзя** было бы вызвать из константного объекта, например запись
```cpp
void printAbs(const Complex& complex)
	{
		std::cout << complex.abs();
	}
```
не скомпилировалась бы, если бы функция abs не была бы объявлена через const 
(так как ссылка на объект complex константная).

```cpp
void add_real(double real)
    {
        re += real;
    }
```
Данная функция прибавляет к вещественной части нашего комплексного числа другое вещественное число.
Обращемся к нему через какой-то объект и передаем число, например `z.add_real(3.14);`

`!` Заметим, что данная функция не может являтся константной, если попытаться написать в его объявлении
    `void add_real(double real) const`
код не скомпилируется, так как мы меняем состояние поля структуры на 51ой строке. 
(` re += real;`)


```cpp
//----------------------------- Конструкторы: -------------------------------
```
- **Конструктор** - это функция, у которого нету возвращаемого типа (даже void), а имя совпадает с именем самой структуры.

**Конструктор** вызывается при создании объекта. 
Например:
```cpp
// конструктор (1)
	Complex(double real_part)
	{
		 re = real_part;
		 im = 0;
	}
```
Чтобы вызвать данный конструктор, необходимо при инициализации объекта передать вещественное число.
Например:
```cpp
int main()
	{
		 Complex z1(23.5); // вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
		 Complex z2 = -2.4; // вызовется конструктор(1) и будет создан объект z2 с полем re = -2.4, im = 0.
	}
```

###### ЗАМЕЧАНИЕ 1: 
Если рядом с объявлением конструктора написать ключегое слово explicit, т. е.
`explicit Complex(double real_part)`, то `Complex z2 = -2.4` не скомпилируется.
Данная запись нужна, если мы хотим вызывать конструктор лишь явным образом, а в `Complex z2 = -2.4` она вызвана неявно.

###### ЗАМЕЧАНИЕ 2: 
Одновременно может существовать несколько конструкторов, если они отличаются аргументами. Например наряду с конструктором (1) можно объявить другой конструктор
```cpp
// конструктор (2)
	Complex(double real_part, double imaginary_part)
	{
		 re = real_part;
		 im = imaginary_part;
	}
```
Конструктор 2 вызовется если передать при создании объекта сразу 2 вещественных числа. 
Например
```cpp
int main()
	{
		 Complex z1(23.5); // вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
		 Complex z2(-2.4, 9.5); // вызовется конструктор(2) и будет создан объект z2 с полем re = -2.4, im = 9.5.
	}
```


```cpp
//----------------------- Конструктор по умолчанию: ------------------------
```
Конструктор, который не получает никаких аргументов называется конструктором по умолчанию (**default constructor**).
Например:
```cpp
// конструктор (3)
	Complex()
	{
		 re = 0;
		 im = 0;
	}
```
Данный конструктор вызывается, если при создании объекта аргументов передано не было, например:
```cpp
int main()
	{
		 Complex z;
	}
```

###### ЗАМЕЧАНИЕ 1:
Если в структуре нету никаких конструкторов, то компилятор генерирует собственный конструктор по умолчанию.

###### ЗАМЕЧАНИЕ 2:
Если в структуре присутствует **хоть** 1 конструктор, то конструктор по умолчанию **не** генерируется. 
	Так например, если объявить лишь конструкторы (1) и (2), то ```Complex z``` не скомпилируется. 
	В ином случае, если никаких конструкторов не объявлено, то компиляция пройдет успешно.

###### ЗАМЕЧАНИЕ 3: 
Конструкторы (1), (2) и (3) можно объединить в 1:
```cpp
// конструктор (4)
	Complex(double real_part = 0, double imaginary_part = 0) 
	{
		re = real_part;
		im = imaginary_part;
	}
```



```cpp
//------------------------ Member initialization: ---------------------------

// конструктор (5)
Complex(double real_part = 0, double imaginary_part = 0) 
	: re(real_part)
	, im(imaginary_part) 
{}
```
Данная запись отличается от конструктора (4) тем, что значения переменным `re` и `im` в (4) задаются уже **после их создания.**

То что происходить в конструкторе (4) эквивалентно следующему:
```cpp
double re;
double im;
re = real_part;
im = imaginary_part;
```
а в конструкторе (5) происходит следующее:
```cpp
double re = real_part;
double im = imaginary_part;
```
т.е. значения в этом случае задаются при создании `re` и `im.`



```cpp
//----------------------- Перегрузка операторов: ---------------------------
```

Легко заметить, что если объявить лишь вышеуказанные методы, следующая запись не будет компилироваться:
```cpp
int main()
	{
		 Complex z1(23.5);
		 Complex z2(-2.4, 9.5);
		 z1 += z2;
	}
```
Связанно это с тем, что операция `+=` неопределена для нашей структуры.
Чтобы эту операцию определить, необходимо перегрузить оператор `+=`. 
Оператор перегружается определением метода с названием `operator+=`, который получает 1 аргумент - второе комплексное число.
Перегрузить можно следующим образом:

```cpp
void operator+=(const Complex& other)
	{
		re += other.re;
		im += other.im;
	}
```
Теперь, на 177ой строке (`z1 += z2;`) будет вызыватся оператор `+=`, а запись `z1 += z2;` эквивалентна `z1.operator+=(z2);`


###### ЗАМЕЧАНИЕ 1: 
На удивление, запись 
```cpp
int main()
	{
		 Complex z(-2.4, 9.5);
		 z += 3.14;
	}
```
скомпилируется. 
Заметим, что `z += 3.14;` эквивалентна `z.operator+=(3.14);` 
Хоть у нас `operator+=` не принимает значение типа `double`, 
`z += 3.14` сперва вызовет конструктор(5) и  оператору `+=` будет передан `other` с полями `re=3.14` и `im=0`.


###### ЗАМЕЧАНИЕ 2:
Заметим, что для обычных чисел (например для `int`-ов)
```cpp
int x = 10;
int y = 20;
```
у выражения `x += y;` кроме побочного эффекта, есть также значение - 30.
Действительно, запись `std::cout << (x += y);` выведет 30, т.е. значение х после прибавления у. 
Если же x и у комплексные, то `x += y` вызовет функцию `operator+=`, а возвращает он `void`.
Т.е. если x и y комплексные, то для `x += y` значения нету (что очень плохо).

Таким образом, чтобы решить данный вопрос, необходимо чтобы метод `operator+=` возвращал бы комплексное число - сам объект, `operator+=` которого был вызван. Т.е. значение записи `z1 += z2` должно равнятся значению `z1` после сложения.
Приходим к записи:
```cpp
Complex operator+=(const Complex& other)
	{
		re += other.re;
		im += other.im;

		return *this;
	}
```
Тут `*this` есть объект, для которого вызвалась функция `operator+=`. Например при записи `z1 += z2`, т.е. `z1.operator+=(z2)` `*this` есть объект `z1`. 


###### ЗАМЕЧАНИЕ 3: 
Оператору `+=` стоит возвращать ссылку на Complex, как указано ниже:
```cp
Complex& operator+=(const Complex& other)
	{
		re += other.re;
		im += other.im;

		return *this;
	}
```
Запись `Complex&` тут по двум причинам:
1. Чтобы `*this` не копировался бы.
2. Так как для обычных чисел запись `x+=y` является ссылкой для х, действительно, в записи:
```cpp
int main()
	{
		int x = 10;
		int y = 20;
		(x+=y) = -7;
	}
```
значение х будет изменено на -7.

Аналогично определяются другие операторы:
```cpp
Complex& operator+=(const Complex& other)
    {
        re += other.re;
        im += other.im;

        return *this;
    }

Complex& operator-=(const Complex& other)
    {
        re -= other.re;
        im -= other.im;

        return *this;
    }

Complex& operator*=(const Complex& other)
    {
        re = re*other.re - im*other.im;
        im = re*other.im + im*other.re;

        return *this;
    }

Complex& operator/=(const Complex& other)
    {
        // сделай сам
        return *this;
    }
```



```cpp
//-------------------------- Другие операторы: ------------------------------

};  //<------------ Заметте, структура заканчивается записью ;

//----------------------- Операторы вне структуры: --------------------------

Complex operator+(Complex lhs, const Complex& rhs)
{
    return lhs += rhs;
}

Complex operator-(Complex lhs, const Complex& rhs)
{
    return lhs -= rhs;
}

Complex operator*(Complex lhs, const Complex& rhs)
{
    return lhs *= rhs;
}

Complex operator/(Complex lhs, const Complex& rhs)
{
    return lhs /= rhs;
}

//-------------------------- Операторы << и >>: -----------------------------

std::ostream& operator<<(std::ostream& out, const Complex& complex)
{
    out << "(" << complex.re << ", " << complex.im << ")";

    return out;
}

std::istream& operator>>(std::istream& in, Complex& complex)
{
    in >> complex.re >> complex.im;
    return in;
}


```
