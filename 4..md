##### 4. l-value/r-value references, std::move, move constructor, move assignment operator, Type casting in c++: static_cast, reinterpret_cast, const_cast.

```cpp
// Функция демонстрирует работу со ссылками (references) 
// и константными ссылками (const references).
void references_and_const_references()
{
    // Инициализируем переменную x значением 19
    int x = 19;
    
    // Создаём копию x в переменной copy.
    // Это отдельная переменная со своим значением.
    int copy = x;

    // Создаём ссылку ref, которая "привязана" к x.
    // Теперь любое изменение через ref затронет x.
    int& ref = x;

    // Изменяем значение copy:
    // Поскольку copy — это отдельная переменная, это НЕ повлияет на x.
    copy = 777;
    std::cout << x << "\n"; 
    // Вывод: 19 (так как x по-прежнему равен 19)

    // Изменяем x через ссылку ref:
    // Поскольку ref ссылается на x, его изменение напрямую меняет x.
    ref = 777;
    std::cout << x << "\n";
    // Вывод: 777 (теперь x равно 777)

    // Создаём константу и константную ссылку на неё.
    // constantInteger — это неизменяемая переменная.
    const int constantInteger = 7;
    const int& constantReference = constantInteger;

    // Создаём константную ссылку на обычную переменную x.
    // Через constantReference2 мы не можем изменить x.
    const int& constantReference2 = x;

    // Создаём константную ссылку на временный объект (x + 123).
    // При этом временный объект "продлевает" своё время жизни
    // до конца области видимости constantReference3.
    const int& constantReference3 = x + 123;
}

// Функция принимает std::string по значению (создаётся копия строки).
void print(std::string str)
{
    std::cout << str;
}

// Функция принимает std::string по неконстантной ссылке.
// Можно изменять переданную строку внутри функции.
void print1(std::string& str)
{
    std::cout << str;
}

// Функция принимает std::string по константной ссылке.
// Копия не создаётся, но исходная строка не может быть изменена внутри функции.
void print2(const std::string& str)
{
    std::cout << str;
}
```

#### Замечания:
   1. *Неконстантный референс* можно создать исключительно на неконстантное l-value выражение того же типа.
   2. Нельзя создать референс *без значения*. Например нельзя просто написать `int& ref`;
   3. Как только референс создан на одну переменную *нельзя* сделать так, чтобы референс ссылался бы на другую переменную.

```cpp
В данной функции объясняется что такое r-value референс.
void r_value_reference()
{
   Будет использовано позже.
   int x = 10;

   
   Те референсы, которые были обсуждены в references_and_const_references() называются l-value референсами и они присутствовали в C++ с самого начала его существования.
   Называются они l-value референсами так как неконстантные референсы могут ссылаться лишь на l-value выражения. Но как мы уже поняли есть потребность создавать функции, которые получали бы l-value значения по-ссылке (чтобь избежать копирования), но могли бы также получать r-value значения (см. функцию print2 в references_and_const_references() ).
   Именно по-этому было решено разрешать присваивать константным ссылкам как l-value, так и r-value значения.
   
   Но что если по каким-то причинам мы хотим создать отдельно 2 функции с одним и тем же именем, так, чтобы первая из них вызывалась бы если было передано l-value значение, а вторая вызывалась бы, если было передано r-value значение?
   
   Как раз для этого случая существуют r-value референсы, которые были добавлены в C++11,
   
   их синтаксис следующий:
   <тип>&& <название референса> = <r-value значение>;
   
   Например:
   int&& r_value_ref = x + 1;

   Замечания:
   1. r-value референс может ссылаться лишь на r-value значение (удлинняя жизнь временной переменной).
      т.е. запись int&& ref=x; привела бы к ошибке компиляции, так как х - l-value.
      
   2. r-value референсы как и l-value референсы должны быть инициализированны, т.е. нельзя писать
      int&& ref; <---- Ошибка компиляции.

--------->[ВОПРОС] Как уже было сказано r-value референс может ссылаться лишь на r-value значение, но сам этот референс представляет из себя нечто l-value или r-value?
То есть может ли он оказаться слева от знака =?
-----> [Ответ]: Так как у r_value_ref есть имя, то оно является l-value.

   Подытожив: r_value_ref может ссылаться лишь на r-value значение, но сам r_value_ref - l-value.
   
   Пример: Можно менять значение r-value референса
   r_value_ref = 19;
   ++r_value_ref;
   r_value_ref /= 10;

   [ЗАМЕЧАНИЕ]: Значение константных r-value референсов поменять нельзя и ссылаться они могут лишь на r-value выражения. 
   Пример:
   const int&& const_r_value_ref = 10 / x + 3 - r_value_ref;

   --------->[ВОПРОС] На что могут ссылаться константные/неконстантные l-value/r-value референсы?
   [Ответ]: Смотри таблицу

//                   |       non-const        |         const        
//-------------------|------------------------|------------------------
// l-value reference | only non-const l-value | any l-value and r-value
//                            expression                 expression      //-------------------|------------------------|------------------------
// r-value reference | only r-value expression| only r-value expression 
//-------------------|------------------------|------------------------


Далее приводятся примеры функций, принимающих l-value и r-value референсы.

void f(int& x) // принимает неконстантный l-value референс.
{
   std::cout << "x was l-value\n";
}

void f(int&& x) // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   f(var);
   f(var + 1);
   f(777);
}

То на f(var) вызовется первая функция,
а на f(var + 1), f(777) вызовется вторая и будет напечатано

x was l-value
x was r-value
x was r-value

Другой пример с константным l-value референсом:
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

Теперь, если написать:
int main()
{
   int var = 17;
   g(var);
   g(var + 1);
   g(777);
}

-------->[ВОПРОС]: И первая и вторая функция могут принимать r-value значения,
Так какая из них вызовется на g(var + 1), g(777)?
[Ответ]: Как ни странно - приоритет получения r-value значений дается именно r-value референсам.
Таким образом мы увидим тот же результат, что и для f:

        x was l-value
        x was r-value
        x was r-value

-------->[ВОПРОС]: Чем отличаются функции g и f?
Ответ: Нельзя передать f константную переменную, например
      
        const int val = 777;
        f(val);

Не скомпилируется, так как
1. f на void f(int& x) принимает неконстантную ссылку, следовательно нельзя передать константное.
2. f на void f(int&& x) строке принимает r-value референс, следовательно нельзя передать l-value.
а val константное l-value значение.

С другой стороны f можно поменять на g в f(val); и компиляция пройдет.

-------->[ВОПРОС]: Что изменилось бы если в void f(int&& x) и void g(int&& x) r-value референсы были константными, т.е.
                   void f(const int&& x)
                   void g(const int&& x)
[Ответ]: Всё что было сказано до этого не изменилось бы. Единственное отличие было бы в том, что внутри самих функций x нельзя было бы поменять.

-------->[САМЫЙ ВАЖНЫЙ ВОПРОС]: Для чего это всё нужно?
[Ответ]: Нужно всё для того, чтобы изменить поведение функции в зависимости от того было ли переданно данной функции l-value или r-value, а надобность этого будет понятна после прочтения того что ниже.
```

---

### **std::move**

```cpp
#include <iostream>
#include <utility>
#include <string>

В данном файле мы поверхностно поймем, что такое move-семантика.

Рассмотрим следующий сценарий: Есть функция, которая принимает std::string по значению
void f(std::string str)
{
   какие-то действия с str.
}

Заметим, что при следующей передаче переменной функции

int main()
{
   std::string name="Barak Obama";
   f(name);
}
  
Переменная name будет скопирована в str.

Подытожим: 

[std::string name="Barak Obama";] 
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

[f(name);]
 _______________         _______________
|     name      |       |      str      |
|---------------|       |---------------|
| "Barak Obama" |       | "Barak Obama" |
 ---------------         ---------------

-------->[ВОПРОС] А что делать если переменная name нам в main уже ненужна?
Ведь тогда логично было бы не создавать копию name, а просто "передать"?

[Ответ]: Если функцию f изменить нельзя - как раз для этого используется std::move.
Если написать

int main()
{
  std::string name="Barak Obama";
  f(std::move(name));
}

тогда name не будет скопирован в str, а будет "сдвинут" str.

Подытожим: 
[std::string name="Barak Obama"]
 _______________
|     name      |
|---------------|
| "Barak Obama" |
 ---------------

[f(std::move(name))]
 _________________         _______________
|       name      |       |      str      |
|-----------------|       |---------------|
| пустое значение |       | "Barak Obama" |
 -----------------         ---------------

Таким образом значение name не будет скопировано, но будет использоваться в str.
Для ясности: "Barak Obama" сохраняется при помощи указателя и вместо того, чтобы скопировать саму строку - копируется лишь указатель, а старый указатель стирается, то есть:

1. Сперва создается переменная name
 ______
| name |
|------|
|   -----------------> "Barak Obama"   
 ------

 2. При создании переменной str копируется лишь адрес строки, а указатель в name стирается

                     _____
                    | str |
                    |-----|
                    |  |  |
                     --|--
                       |
                       |
 ______                |
| name |               |
|------|               v
|      |          "Barak Obama"
 ------

---------->[ЗАМЕЧАНИЕ] После std::move переменной name пользоваться нельзя, непонятно какое значение внутри name, что приводит к undefined behavior.

Поймём как работает std::move.

Снова вернемся к этому примеру:
void g(const int& x) // принимает константный l-value референс.
{
   std::cout << "x was l-value\n";
}

void g(int&& x)      // принимает неконстантный r-value референс.
{
   std::cout << "x was r-value\n";
}

------>[ВОПРОС] Что если у нас есть переменная int val=555; и мы хотим передать его функции g, но хотим, чтобы вызвалась не функция void g(const int& x), а void g(int&& x)?
 Причем мы не хотим менять сами функции.
Очень Странный Ответ: Использовать std::move, а именно

       int val = 555;
       g(std::move(val)); // напечатает "x was r-value"

------>[ВОПРОС] Что же делает std::move? Почему это работает так?
Ответ: Единственная функция std::move - полученное l-value значение преобразовать в r-value.
Как раз поэтому на 
       [g(std::move(val)); // напечатает "x was r-value"]
вызовется функция void g(int&& x), хоть val и l-value.

------>[ВОПРОС] А как же тогда всё работает для std::move(name) из f(std::move(name))?
Ответ: std::string имеет 2 конструктора. Первый из них - это copy-constructor, который принимает l-value reference.
       
       string(const string& other);

Данный конструктор копирует всю строку other в создаваемый объект.
Второй же конструктор принимает r-value reference.

       string(string&& other);

И копирует лишь указатель строки other в создаваемый объект, далее стирает указатель other (именно поэтому тут не const).
       
Таким образом, вернувшись к функции f, если переменная была передана ей не используя std::move, т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(name);
       }
То для name будет вызван copy-constructor, так как name l-value и вызовется конструктор string(const string& other).

Если же перед передачей сделать std::move(name), т.е.
       int main()
       {
          std::string name="Barak Obama";
          f(std::move(name));
       }
Тогда из-за того, что std::move(name) r-value вызовится конструктор, принимающий r-value reference: string(string&& other).

Конструктор string(string&& other) называется мув конструктором.
```
- **Определение**: `std::move` — это функция, которая преобразует l-value в r-value, позволяя передать временный объект в функции или конструкторы перемещения.
---

## **Конструктор перемещения (move constructor)**

- ***Определение***: Конструктор перемещения позволяет передавать ресурсы (например, динамическую память) от одного объекта к другому без копирования.
- *Синтаксис:
  ```cpp
  class MyClass {
  private:
	  int* data;

  public:
	  MyClass(int value) {
		  data = new int(value);
	  }

	  // Конструктор перемещения
	  MyClass(MyClass&& other) noexcept : data(other.data) {
		  other.data = nullptr; // Обнуляем указатель в исходном объекте
	  }

	  ~MyClass() {
		  delete data;
	  }
  };
  ```
- **Особенности**:
  - Конструктор перемещения вызывается, если объект передаётся как r-value.

---

### Оператор присваивания с перемещением (move assignment operator)

- ***Определение***: Оператор перемещающего присваивания используется для переноса ресурсов между объектами.
- *Синтаксис*:
  ```cpp
  MyClass& operator=(MyClass&& other) noexcept {
	  if (this != &other) {
		  delete data;
		  data = other.data;
		  other.data = nullptr;
	  }
	  return *this;
  }
  ```
- **Особенности**:
  - Необходимо очищать текущие ресурсы перед переносом.
  - Обеспечивает защиту от самоприсваивания.

---
## Приведение типов в C++ (type casting in c++)

### static_cast
- **Определение**: Используется для проверяемого преобразования типов во время компиляции. Преобразует, если существует логическая связь и преобразование не приводит к потери данных.

- **Пример**:
  ```cpp
  double d = 3.14;
  int i = static_cast<int>(d); // Убрана дробная часть
  ```
- **Особенности**:
  - Используется для приведения указателей между базовым и производным классами.

### reinterpret_cast
- **Определение**: 
  Это низкоуровневое преобразование, которое **не меняет содержимое памяти**. Оно просто интерпретирует её как другой тип. 
  Используется для небезопасного преобразования типов. 
  Если мы уверены, что преобразование *не приведёт* к undefined behavior, то можем сделать этот каст. 
  *В отличие* от других видов приведения (`static_cast`, `const_cast`), `reinterpret_cast` чаще всего используется для низкоуровневых преобразований, связанных с указателями, функциями и значениями.
  
-  **Синтаксис**
```cpp
reinterpret_cast<тип-назначения>(выражение);
```
- **`тип-назначения`** — это тип, в который нужно преобразовать объект.
- **`выражение`** — это значение, которое нужно преобразовать.

- **Пример**:
  ```cpp
  int* p = reinterpret_cast<int*>(0x1234);
  ```
  После преобразования, `p` становится указателем на память по адресу `0x1234`. Однако сам адрес памяти может быть недействительным или указывать на случайные данные.
- **Особенности**:
  - Позволяет интерпретировать битовое представление одного типа как другого.
  - Используется с осторожностью, так как может привести к неопределённому поведению.

### const_cast
- **Что делает `const_cast`?**  
    Убирает или добавляет модификатор `const` (и/или `volatile`) у указателей или ссылок.
    - **Синтаксис**
		`const_cast<тип-назначения>(выражение);`
		- **`тип-назначения`** — это новый тип, который вы хотите получить.
		- **`выражение`** — это значение, которое вы преобразуете.
    
- **Когда использовать?**
    - При необходимости вызвать функцию, которая ожидает неконстантный параметр, но у вас есть константный объект.
    ```cpp
	#include <iostream>
	void modify(int& value) {
	    value = 100;
	}
	
	int main() {
	    int x = 42; // Объявлен без const
	    const int& ref_x = x; // ref_x имеет квалификатор const
	
	    modify(const_cast<int&>(ref_x)); // Удаление const, корректно
	    std::cout << "x = " << x << '\n'; // Вывод: x = 100
	    return 0;
	}
    ```
    > Здесь поведение определено, так как исходный объект `x` не является `const`.
    
- **Когда НЕ использовать?**
    
    - Если вы пытаетесь изменить изначально `const` объект — это *всегда* приводит к неопределённому поведению.
    ```cpp
int main() {
    const int x = 42;
    int* p = const_cast<int*>(&x);
    *p = 24; // Неправильное использование (неопределённое поведение)
    std::cout << x << '\n'; // Результат может быть любым
    return 0;
}
```
> **Почему UB (неопределённое поведение)?**  
> Объект `x` изначально объявлен как `const`, и изменение его значения недопустимо.
